new_head "RegisterArmor()"
new_text "RegisterArmor(object gear, mixed *params)...You can't RegisterArmor the same piece of eq more than once.It overwrites the other params. Unfortunately this means thatyou have to ghetto code something like a shield that blocksother|fire and other|ice. I'm not sure when I'll fix this :/"
tmp_head "Weapon Returns(feldegast, Oct  3, 100)**Weapon Values(feldegast, Jan 23, 100)**Fireball Damage(feldegast, Jan 23, 100)**call_out(francesco, Nov 20, 40)**re: call_out(wizardchild, Dec  9, 100)**extra_look()(vertebraker, May 15, 1000)**multiple id()(vertebraker, May 30, 1000)**restore_object() bug(vertebraker, Jul 11, 1000)**query_prop(vertebraker, Aug  8, 1000)**.o file bug(vertebraker, Aug  8, 1000)**call_out (again)(francesco, Aug 29, 70)**re verte .o file bug(boltar, Oct  3, 100000)**Mappings and save_object()(earwax, Jul 16, 21)**re: Mappings and save_object()(vertebraker, Aug  4, 1000)**first_inventory() bug(earwax, Dec  5, 30)**re:first_inventory()(earwax, Dec  5, 30)**variable defs inside function declarations(vital, Jan 14, 100)**call_out and input_to(vertebraker, Jun 10, 1000)**reset()(illarion, Mar 11, 1000)**RegisterArmor()(x, Aug  6, 100)**dohhhhmappings(wizardchild, Apr 18, 100)**dohhhhmappings(wizardchild, Apr 18, 100)**dohhhhmappings(wizardchild, Apr 18, 100)**Reconnect(balowski, May 12, 21)**Reconnect(balowski, May 12, 21)**Reconnect(balowski, May 12, 21)**Reconnect(balowski, May 12, 21)**re: channels(wizardchild, Apr 30, 30)**re: channels(wizardchild, Apr 30, 30)**re: channels(wizardchild, Apr 30, 30)**"
tmp_text "Here's the same chart, but each weapon now has a 1/3 chanceof a return of 7.WC      16      17      18      19      20--------------------------------------------AC1  	9.8	10.3	10.8	11.3	11.8AC2  	9.4	9.8	10.3	10.9	11.3AC3  	8.9	9.4	9.9	10.4	10.9AC4  	8.4	9.0	9.4	9.9	10.4AC5  	8.0	8.5	9.0	9.5	10.0AC6  	7.6	8.1	8.6	9.1	9.6AC7  	7.2	7.7	8.2	8.7	9.2AC8  	6.9	7.3	7.8	8.3	8.8AC9  	6.5	7.0	7.4	7.9	8.4AC10  	6.2	6.6	7.1	7.5	8.0AC11  	5.8	6.3	6.7	7.2	7.6AC12  	5.5	6.0	6.4	6.9	7.3AC13  	5.2	5.7	6.1	6.5	7.0AC14  	4.9	5.4	5.8	6.2	6.7AC15  	4.7	5.1	5.5	5.9	6.4AC16  	4.5	4.8	5.3	5.7	6.1AC17  	4.2	4.6	5.0	5.4	5.8AC18  	4.0	4.4	4.8	5.2	5.6AC19  	3.8	4.2	4.5	4.9	5.3AC20  	3.6	4.0	4.3	4.7	5.1Yours truly,Feldegast**A number of wizards have asked me about the relative worth ofweapons of different weapon classes.  Here, for your amusementis a chart containing average damage for WC16-20 against AC1-20.Hopefully this'll give you an idea of their effectiveness.WC      16      17      18      19      20-------------------------------------------AC1  	07.0	07.5	08.0	08.5	09.0AC2  	06.6	07.1	07.6	08.1	08.6AC3  	06.2	06.7	07.1	07.6	08.1AC4  	05.7	06.2	06.7	07.2	07.7AC5  	05.4	05.8	06.3	06.8	07.3AC6  	05.0	05.5	05.9	06.4	06.9AC7  	04.7	05.1	05.6	06.0	06.5AC8  	04.3	04.8	05.2	05.7	06.2AC9  	04.0	04.5	04.9	05.4	05.8AC10  	03.8	04.2	04.6	05.1	05.5AC11  	03.5	03.9	04.3	04.7	05.2AC12  	03.2	03.6	04.1	04.5	04.9AC13  	03.0	03.4	03.8	04.2	04.6AC14  	02.8	03.2	03.6	04.0	04.4AC15  	02.7	03.0	03.4	03.7	04.1AC16  	02.5	02.8	03.2	03.5	03.9AC17  	02.4	02.7	03.0	03.3	03.7AC18  	02.2	02.5	02.8	03.2	03.5AC19  	02.1	02.4	02.7	03.0	03.3AC20  	02.0	02.3	02.6	02.9	03.2AC21  	01.9	02.2	02.4	02.7	03.0AC22  	01.8	02.1	02.3	02.6	02.9AC23  	01.8	02.0	02.2	02.5	02.8AC24  	01.7	01.9	02.1	02.4	02.7.**Fireball damage at different wc's vs different ac's.WC      16      17      18      19      20-------------------------------------------AC1  	28.9	29.3	29.8	30.4	30.8AC2  	28.3	28.8	29.3	29.8	30.3AC3  	27.8	28.3	28.8	29.4	29.8AC4  	27.3	27.8	28.3	28.9	29.3AC5  	26.9	27.3	27.9	28.3	28.9AC6  	26.4	26.8	27.3	27.8	28.3AC7  	25.9	26.4	26.8	27.3	27.9AC8  	25.4	25.9	26.3	26.9	27.4AC9  	24.9	25.4	25.9	26.5	26.9AC10  	24.4	24.9	25.3	26.0	26.4AC11  	23.9	24.5	24.9	25.5	26.0AC12  	23.6	23.9	24.4	24.9	25.4AC13  	23.1	23.4	24.0	24.4	25.0AC14  	22.4	23.0	23.6	24.0	24.5AC15  	22.1	22.5	23.0	23.6	24.0AC16  	21.6	22.1	22.6	23.1	23.6AC17  	21.2	21.7	22.2	22.6	23.1AC18  	20.7	21.2	21.6	22.2	22.6AC19  	20.2	20.8	21.2	21.7	22.2AC20  	19.8	20.3	20.8	21.3	21.8AC21  	19.5	20.0	20.4	20.9	21.3AC22  	19.0	19.4	19.9	20.5	20.9AC23  	18.7	19.1	19.5	20.0	20.4AC24  	18.2	18.6	19.1	19.6	20.0**I found out that when you are using a call_out("functionname",delay) the this_player() makes the function unexecutable at all.Upon Jenny's advice and after some experimenting, I did this:object dude; dude = this_player(); blah blah blaheverything worked fine.well, i know that most important is to have the things working fine..... but.... did it make any sense????anyone willing to explain the rationale of this?thanksfran**yeah, the basic idea of "this_player()" is that you have an active playeryou can reference. in the event of a normal command that you run,this_player() returns the player who ran the command.with call_out, the driver is making the call, so there is no playerassociated with the call; rather, the call is associated withthe driver.there's a bunch of stuff with call_out() in my dir if you needexamples.lates**Just a little idea  ..When you do objs with an extra_look(), why not make it say"You blah blahblah " when they look at themselves?extra_look(){    if(environment() == this_player())      write("You have a big boner.\n");    else      write(environment()->query_name() + " has a big boner.\n");}As an example :)~v**To add another id to an inherited armor or weapon,try something like:id(str) { return (::id(str) || str == "id_to_add"); }This will use the inherited id's [i.e. set_name(),set_alias(), set_alt_name(), etc. ..]and will add the others as well.**I recently discovered a very strange bug.restore_object() errors if it tries to restore an arrayof strings if one of them has a backslash at the end of it.Just bringing this to your attention.. to prevent this withthe new quicktyper lib commands, I wrote some preventivecode that perhaps you could weld to your usage in the eventof this very strange bug.     sa = strlen(arg1)-1;     sb = strlen(arg2)-1;     if(arg1[sa..sa]=="\\" || arg2[sb..sb] == "\\")      return (write("Due to a weird driver bug, aliases may not have\n" +                    "a backslash [\\] at the end of either the alias\n" +                    "or definition.  Sorry for any problems this may\n"+                    "cause you.\n"), 1);This isn't a very common error, but apparently it can causea problem.**query_property() in room.c is more of a fun to be usedwithin the room obj itself, not to be queried by spells,since it will only return the indices within the arrayof property.Just do your checks for no magic areas and so forthlike you normally would..use add_property()/remove_property() for initializingthe rooms to whatever :)I know it's confusing.. but I strove for compatibilityrather than functionality when I wrote it.			verte**If you edit a file with a huge string on one line,it will crash the mud.  So instead, just ftpthe file, edit in wordpad or some tool, then ftpit back, cp, etc. boom.It's happened a couple times, so just lettingyou know.**With reference to my earlier note #4, i again experienced the same problem when using the this_player()->set_quest("mastermind")command to add quest points.  Well, i took it outside of thecall_out and it worked ok.just a reminder for those of you who are planning to code a questfran** .o files with long lines should never be edited by the mud editor. at best it will corrupt thesave file, at worst it will crash the mud as verte points out.**mappings don't save in save_object()?i have no problem with any other data types, but mappings simplyseem to be invisible to save_object() and restore_object(), is thereany way around this other than to convert arrays to mappings in reset()and then back to arrays when you save? i was putting together a daemon where mapping was pretty much the idealdata type to use, but having a mapping and 2 arrays seems like it's a bitinefficient in this area.**No.And, No.**I am having a weird bug with first_inventory().  It appears that when it's called by amonster (I've never seen it bug up in other code called by a player) and using this_object(), it bugs if the first_inventory() in the room is this_object() itself.  Tryingto work around it with all_inventory() but that I know also has a habit of bugging upin strange and senseless ways.  Anyways, there any way to work around it or haveit not bug up?  I'd use this_player() but the way I have it setup, there's no guaranteethat the mob would be this_player() instead of a player, at times.**Bah, I'm using this_player() and it's going fine.  I'd stilllike to know if anyone has any idea on why it bugs thatway though.  Is it a driver bug (which is what I assume)or is there another way to work around it other than byusing this_player() (just in case I ever have to use it thatway)?**For what it's worth, the current driver doesn'tsupport the definition of a variable within the declaration of a function.Example:int my_function(string str = "bob", int x)will not evaluate correctly. The solution then forthose times is to use varargs, i.e.int varargs my_function(string str, int x)which will accomplish the same thing.VitalYour friendly neighborhood code-hoodlum[Keeping it Ghetto]**Strange brew, this driver of ours.I just discovered if you do a call_out() before an input_to(),it will cause the input_to() to have all sorts of problems.But if you do the call_out() AFTER the input_to(), it willwork perfectomundo.And btw this was all in the same function.**As far as I know, there's no way to keep reset() from being called in an objectperiodically.  However, reset() is always passed an argument- when the objectis first loaded, that argument is 0; subsequently, it is non-zero.  So, if you startyour reset function out thusly:void reset(status arg) {  if(arg) return;Any initializations you have below should be safe from periodic reset() calls.Note: if you're inheriting another object with reset, make sure to put ::reset(arg)before your if(arg) return;.**RegisterArmor(object gear, mixed *params)...You can't RegisterArmor the same piece of eq more than once.It overwrites the other params. Unfortunately this means thatyou have to ghetto code something like a shield that blocksother|fire and other|ice. I'm not sure when I'll fix this :/**You guys are silly. The driver has mappings. if you are creative enough youcan save them. It just requires some additional effort. Maybe an additionalsave file. like you have a wizardchild.o and a wizardchild.mapI have some code on it beck if you'd like to see how. Just mail me.-Wiz-**You guys are silly. The driver has mappings. if you are creative enough youcan save them. It just requires some additional effort. Maybe an additionalsave file. like you have a wizardchild.o and a wizardchild.mapI have some code on it beck if you'd like to see how. Just mail me.-Wiz-**You guys are silly. The driver has mappings. if you are creative enough youcan save them. It just requires some additional effort. Maybe an additionalsave file. like you have a wizardchild.o and a wizardchild.mapI have some code on it beck if you'd like to see how. Just mail me.-Wiz-**Most of you have probably noticed that the login procedure haschanged somewhat when logging in after a disconnection. Beforethe change,  the old player shell was destructed  after movingits inventory to the new player shell. Hence a wiz could neverrely on  the player object to stay invariable  in the timespanfrom a login to a quit.If we get to keep the change made, life ( coding ) should be abit easier. Now, the new connection is bound to the old playershell when logging in after a disconnection.  The first effectis that the player object for a given player will never changeunless  the player quits  and reenters the game.  I,  for one,will exploit ( already have exploited ) this fact and identifythe player by the object rather than by the name.  find_playershould be relatively  cheap in execution time,  so my guess isthat there is no  huge speed increase  to be found,  but stillprograms can be made faster and more compact at places.The second big effect is that players do not remove armour andweapons when they reconnect.  I have always been wanting to bemean to the players and give them cursed equipment, be it verygood or very bad equipment. I think this is my time *grin*Players can still stop a fight by disconnecting and reenteringas far as I know,  but this should in theory be easy to alter.  Balowski, techno buff not looking for a life[Coding by me.  Bug-fixing by Boltar if I am not mistaken :^)]**Most of you have probably noticed that the login procedure haschanged somewhat when logging in after a disconnection. Beforethe change,  the old player shell was destructed  after movingits inventory to the new player shell. Hence a wiz could neverrely on  the player object to stay invariable  in the timespanfrom a login to a quit.If we get to keep the change made, life ( coding ) should be abit easier. Now, the new connection is bound to the old playershell when logging in after a disconnection.  The first effectis that the player object for a given player will never changeunless  the player quits  and reenters the game.  I,  for one,will exploit ( already have exploited ) this fact and identifythe player by the object rather than by the name.  find_playershould be relatively  cheap in execution time,  so my guess isthat there is no  huge speed increase  to be found,  but stillprograms can be made faster and more compact at places.The second big effect is that players do not remove armour andweapons when they reconnect.  I have always been wanting to bemean to the players and give them cursed equipment, be it verygood or very bad equipment. I think this is my time *grin*Players can still stop a fight by disconnecting and reenteringas far as I know,  but this should in theory be easy to alter.  Balowski, techno buff not looking for a life[Coding by me.  Bug-fixing by Boltar if I am not mistaken :^)]**Most of you have probably noticed that the login procedure haschanged somewhat when logging in after a disconnection. Beforethe change,  the old player shell was destructed  after movingits inventory to the new player shell. Hence a wiz could neverrely on  the player object to stay invariable  in the timespanfrom a login to a quit.If we get to keep the change made, life ( coding ) should be abit easier. Now, the new connection is bound to the old playershell when logging in after a disconnection.  The first effectis that the player object for a given player will never changeunless  the player quits  and reenters the game.  I,  for one,will exploit ( already have exploited ) this fact and identifythe player by the object rather than by the name.  find_playershould be relatively  cheap in execution time,  so my guess isthat there is no  huge speed increase  to be found,  but stillprograms can be made faster and more compact at places.The second big effect is that players do not remove armour andweapons when they reconnect.  I have always been wanting to bemean to the players and give them cursed equipment, be it verygood or very bad equipment. I think this is my time *grin*Players can still stop a fight by disconnecting and reenteringas far as I know,  but this should in theory be easy to alter.  Balowski, techno buff not looking for a life[Coding by me.  Bug-fixing by Boltar if I am not mistaken :^)]**Most of you have probably noticed that the login procedure haschanged somewhat when logging in after a disconnection. Beforethe change,  the old player shell was destructed  after movingits inventory to the new player shell. Hence a wiz could neverrely on  the player object to stay invariable  in the timespanfrom a login to a quit.If we get to keep the change made, life ( coding ) should be abit easier. Now, the new connection is bound to the old playershell when logging in after a disconnection.  The first effectis that the player object for a given player will never changeunless  the player quits  and reenters the game.  I,  for one,will exploit ( already have exploited ) this fact and identifythe player by the object rather than by the name.  find_playershould be relatively  cheap in execution time,  so my guess isthat there is no  huge speed increase  to be found,  but stillprograms can be made faster and more compact at places.The second big effect is that players do not remove armour andweapons when they reconnect.  I have always been wanting to bemean to the players and give them cursed equipment, be it verygood or very bad equipment. I think this is my time *grin*Players can still stop a fight by disconnecting and reenteringas far as I know,  but this should in theory be easy to alter.  Balowski, techno buff not looking for a life[Coding by me.  Bug-fixing by Boltar if I am not mistaken :^)]**Funny, I coded a similar object on my own intuition about 2 weeks ago...Got amain chat object of exactly 1k, with 3 channels supported. Simple object.The trade off, really, is maintaining the array (no hassle for you, i'd guess). I haven't taken the time to try out this method, unfortunately.-Wiz-**Funny, I coded a similar object on my own intuition about 2 weeks ago...Got amain chat object of exactly 1k, with 3 channels supported. Simple object.The trade off, really, is maintaining the array (no hassle for you, i'd guess). I haven't taken the time to try out this method, unfortunately.-Wiz-**Funny, I coded a similar object on my own intuition about 2 weeks ago...Got amain chat object of exactly 1k, with 3 channels supported. Simple object.The trade off, really, is maintaining the array (no hassle for you, i'd guess). I haven't taken the time to try out this method, unfortunately.-Wiz-**"
msg_num 20

/*
// This is a mudlib file.
// The functions defined in this file should only be replacements of efuns
// no longer supported. Don't use these functions any longer, use the
// replacement instead.
*/

/* ===========================================================================
 * Modified to work with both drivers (Amylaar and LD) - by using ifdef
 * at the top of this file, the current simul_efun file is used for Amylaar
 * and the code below the else is used on LD.  This should make the switch
 * easer, as we can just remove the top portion of the code when done
 * testing and we are fully migrated. - Rumplemintz
 * ===========================================================================
 */

#ifndef __LDMUD__  /* Not using LD Driver */

inherit "/obj/simul_efun/secure/overrides";

inherit "/obj/simul_efun/resolv_path";
inherit "/obj/simul_efun/loadObject";
#if 0 /* Change this to 1 to put it back in - Rumplemintz */
inherit "/obj/simul_efun/check_file";
#endif
inherit "/obj/simul_efun/exclude_array";
inherit "/obj/simul_efun/emit_channel";
inherit "/obj/simul_efun/destruct";
inherit "/obj/simul_efun/m_efuns";
inherit "/obj/simul_efun/matching_arrays";
inherit "/obj/simul_efun/expand_month";
inherit "/obj/simul_efun/basename";
/*
inherit "/closed/verte/command_efun";
*/
inherit "/obj/simul_efun/valid_player";
inherit "/obj/simul_efun/same_array";
inherit "/obj/simul_efun/format_colour";
inherit "/obj/simul_efun/a_delete";
inherit "/obj/simul_efun/elongate_attrib";
inherit "/obj/simul_efun/ip";
inherit "/obj/simul_efun/wizlist";
inherit "/obj/simul_efun/ascii_glyph";
inherit "/obj/simul_efun/waxfuns";
inherit "/obj/simul_efun/update_actions"; /* Rumplemintz */
inherit "/obj/simul_efun/comma_number";

inherit "/obj/simul_efun/find_all_living";

/* Temporary til we switch */
string object_name(object ob) { return file_name(ob); }

#pragma strict_types
#pragma save_types
#pragma verbose_errors

/*
// The old 'slice_array' is no longer needed. Use range argument inside
// a pair of brackets instead.
*/
mixed *slice_array(mixed *arr, int from, int to) {
  return arr[from..to];
}

/*
// filter_objects() has been renamed to filter_array().
*/
mixed *filter_objects(mixed *list, string str, object ob, mixed extra) {
  return filter_array(list, str, ob, extra);
}

/*
// Define functions to return the proper third person pronoun based on
// gender.
*/
string
subjective(object ob) {
  string gender;
  if (!ob) {
    ob = this_player();
    if (!ob)
      return "it";
  }
  gender = (string)ob->query_gender();
  if (gender == "male")
    return "he";
  else if (gender == "female")
    return "she";
  else
    return "it";
}

string
objective(object ob) {
  string gender;

  if (!ob) {
    ob = this_player();
    if (!ob)
      return "it";
  }
  gender = (string)ob->query_gender();
  if (gender == "male")
    return "him";
  else if (gender == "female")
    return "her";
  else
    return "it";
}

string
possessive(object ob) {
  string gender;

  if (!ob) {
    ob = this_player();
    if (!ob)
      return "its";
  }
  gender = (string)ob->query_gender();
  if (gender == "male")
    return "his";
  else if (gender == "female")
    return "her";
  else
    return "its";
}
mixed snoop(mixed snoopee) {
  if(snoopee && this_player()->query_level() < snoopee->query_level()){
    write("Failed.\n");
    return 1;
   }
if(snoopee)
 efun::snoop(snoopee);
else efun::snoop();
  return 1;
}
int tell_object_wblock(object to, string what) {
  object from;
  if(this_player()) from = this_player();
  if(!from) { efun::tell_object(to,what); return 1;}
  if(from->query_level() < 21 && !from->query_npc()) 
  if(to->query_tellblock(from)) { 
    efun::tell_object(from,to->query_name()+" is blocking you.\n");
    return 1;
  }
  efun::tell_object(to,what);
}

/*  mal is a whiner.

     WAH WAH WAH LOOK AT ME IM MAL.. cry :)

     hehe
void wizlist();
*/

void dumb();  /* heh.. */
void break_point(); /* YAY */

string
delete_spaces(string arg)
{
    return (implode(explode(arg, " "), ""));
}

/* Simul_efun: resolve_path()
 * string resolve_path(string arg)
 *
 * See /doc/efun/resolve_path
 *
 * - Earwax 5/20/04
 *
 * Added ~/ support, cleaned up code a wee bit.
 * also changed file_size() check to 
 *  .... file_size()
 * [verte] <5-20-04>
*/

string resolve_path(string arg)
{
  int i, siz;
  string junk, junk2, path, filename, *args;
  object y;

  if (!arg) return 0;
  if (arg == "/") return arg;
    
  y = this_player();

  if (arg == "~")
    return "/players/"+(string)y->query_real_name()+"/";
    
  if (text_contains(arg, "~"))
  {
    if (y && sscanf(arg, "~/%s",junk))
      arg = "/players/" + 
       (string)y->query_real_name() + "/" + junk;
    else if (sscanf(arg, "~%s/%s", junk, junk2) == 2)
      arg = "/players/"+junk+"/"+junk2;
    else if (sscanf(arg, "~%s", junk) == 1)
    {
	    junk2 = "/players/"+(string)y->query_real_name()+"/"+junk;
	    arg = (file_size(junk2)) ? junk2 : "/players/"+junk;
    }
  }

  if (arg[0] != '/')
    arg = (y && (int)y->query_level() > 19) ? 
           (string)y->query_pwd() + arg :
           "/" + arg;

  if (text_contains(arg, ".."))
  {
    string b, c, *t;
    int x;

    t = ({ });
    b = (arg[strlen(arg)-1]=='/') ? "/" : "";
    siz = sizeof(args = explode(arg, "/"));
    
    for (i = 0; i < siz; i++)
    {
	    if (args[i] == ".")
	      continue;
	    else if (args[i] != "..")
	      t += ({ args[i] });
	    else
	    {
		    x = sizeof(t) - 1;
        t = (x) ? t[0..x-1] : ({ });
	    }
    }
    arg = "/"+implode(t, "/")+b;
  }
  i = strlen(arg)-1;
  if (arg[i] != '/' && file_size(arg+"/") == -2)
    arg += "/";
    
  while (text_contains(arg, "//"))
  {
	  if (sscanf(arg, "//%s", arg) == 1)
	    arg = "/"+arg;
	  if (sscanf(arg, "%s//%s", arg, junk) == 2)
	    arg = arg + "/" + junk;
	  if (sscanf(arg, "%s//", arg) == 1)
	    arg += "/";
  }
  
  return arg;
}

status is_vowel(mixed char)
{
    return((
      char=="a"||char=='a'||
      char=="e"||char=='e'||
      char=="i"||char=='i'||
      char=="o"||char=='o'||
      char=="u"||char=='u') ? 1 : 0);
}

string a_or_an(string phrase)
{
  phrase = delete_colour(phrase);
  return (is_vowel(phrase[0])?"an":"a");
}

varargs mixed expand_player(string input, int epType)
{
  object *us, nm;
  mixed  obj, nmr;
  string *heh;
  int    s;
  s = sizeof(us = users());
  heh = ({ });
  while(s--)
    if((nm = us[s]) && (nmr = (string)nm->query_real_name()) &&
       (nmr[0..strlen(input)-1] == input) &&
       (obj = efun::find_player(nmr)))
         heh += ({ nmr });
  switch(s=sizeof(heh))
  {
    case 0: return (!epType ? input : 0);
    case 1: return efun::find_player(heh[0]);
    default:
      write("\
Try again.\n"+s+" \
players with a name beginning with \""+input+"\".\n\
You must specify which player you mean a little more clearly.\n");
      write("Possible targets found: ");
      while(s-- > 1) write(capitalize(heh[s])+", ");
      write(capitalize(heh[s])+".\n");
      return;
  }
  return 0; /* Rumplemintz */
}

/* 11/16/06 Earwax: ghetto'd this to try to hack way around invis 60
 *                  issue that's causing some problems with logging
 */
varargs object find_player(string str, int fpType)
{
  object *obs;
  object obj;
  int i;
  
  if (!str) return 0;
  if(obj = efun::find_player(str)
  ) /*
  || (obj = find_object(str) && living(obj) && (int)obj->is_player()))
*/
    return obj;
  else if (i = sizeof(obs = users()))
  {
    while(i--)
    {
      if ((string)obs[i]->query_real_name() == str)
        return obs[i];
    }
  }
  else if(fpType)
    return expand_player(str, 1);
  return 0;

  /* Original code - Earwax     
  object obj;
  if(obj = efun::find_player(str))
    return obj;
  else if(fpType)
    return expand_player(str, 1);
  */
}

string creator(object ob) { return (objectp(ob) ? efun::creator(ob) : 0); }

void println(string str) { return write((str ? str : "") + "\n"); }

#else /* Using the LD Driver - use code below - Rumplemintz */

#pragma strict_types
#pragma no_clone
#pragma no_inherit

#include "/include/config.h"
#include "/include/mudlib.h"

#include "/secure/simul/add_ansi.c"
#include "/secure/simul/compat.c"
#include "/secure/simul/add_worth.c"
#include "/secure/simul/base_file.c"
#include "/secure/simul/create_wizard.c"
#include "/secure/simul/log_file.c"
#include "/secure/simul/living_handlers.c"
#include "/secure/simul/living.c"
#include "/secure/simul/rooms.c"
#include "/secure/simul/rtime.c"
#include "/secure/simul/snoop.c"
#include "/secure/simul/subst.c"
#include "/secure/simul/type_handlers.c"

#include "/sys/wizlist.h"
#include "/sys/erq.h"
#include "/sys/files.h"

#if 0
/* New sefuns for LD - Rumplemintz */
private inherit "kernel/support/name";

inherit "kernel/simul/events";
inherit "kernel/simul/shared";
inherit "kernel/simul/fold";
inherit "kernel/simul/array";
inherit "kernel/simul/list";
#if 0
inherit "kernel/simul/file";
#endif
inherit "kernel/simul/lpc";
inherit "kernel/simul/string";
inherit "kernel/simul/actions";
inherit "kernel/simul/bits";
inherit "kernel/simul/mapping";
inherit "kernel/simul/game";
#if 0
inherit "kernel/simul/debug";
#endif
inherit "kernel/simul/message";

#ifdef NEW_LIGHT
inherit "kernel/simul/light";
#endif

#ifdef SIMUL_INPUT_TO
inherit "kernel/simul/input_to";
#endif
#endif

#if 0
/* Compatibility sefuns - Rumplemintz */
#include "/obj/simul_efun/keys.c"
#include "/obj/simul_efun/atoi.c"
#include "/obj/simul_efun/file_name.c"
#include "/obj/simul_efun/file_exists.c"
#include "/obj/simul_efun/member_array.c"
#include "/obj/simul_efun/format.c"
#include "/obj/simul_efun/pad.c"
#include "/obj/simul_efun/index.c"
#include "/obj/simul_efun/caller.c"
#include "/obj/simul_efun/in_editor.c"
#include "/obj/simul_efun/delete_spaces.c"
#include "/obj/simul_efun/grab_file.c"
#include "/obj/simul_efun/pronoun.c"
#include "/obj/simul_efun/root.c"
#include "/obj/simul_efun/save_restore.c"
#include "/obj/simul_efun/attribute.c"

/* Nirvana sefuns */
#include "/obj/simul_efun/basename.c"
#include "/obj/simul_efun/emit_channel.c"
// #include "/obj/simul_efun/file_size.c"
#include "/obj/simul_efun/m_efuns.c"
#include "/obj/simul_efun/a_delete.c"
#include "/obj/simul_efun/valid_player.c"
#include "/obj/simul_efun/waxfuns.c"
#include "/obj/simul_efun/resolve_path.c"
#include "/obj/simul_efun/update_actions.c"
#include "/obj/simul_efun/comma_number.c"
#include "/obj/simul_efun/resolv_path.c"  /* This is silly to have two... */
#include "/obj/simul_efun/loadObject.c"
#include "/obj/simul_efun/find_all_living.c"
#endif

//---------------------------------------------------------------------------
void localcmd()
{
    string *verbs;
    int i,j;

    verbs = query_actions(this_player());
    for (i=0, j = sizeof(verbs); --j >= 0; i++) {
	write(verbs[i]+" ");
    }
    write("\n");
}

//---------------------------------------------------------------------------
mixed *unique_array(mixed *arr,string func,mixed skipnum)
{
    mixed *al, last;
    mapping m;
    int i, j, k, *ordinals;

    if (sizeof(arr) < 32)
        return efun::unique_array(arr, func, skipnum);
    for (ordinals = allocate(i = sizeof(arr)); i--; )
	    ordinals[i] = i;
    m = mkmapping(map_objects(arr, func), ordinals, arr);
    al = m_indices(m);
    ordinals = m_values(m, 0);
    arr = m_values(m, 1);
    if (k = i = sizeof(al)) {
        for (last = al[j = --i]; i--; ) {
            if (al[i] != last) {
                if (last != skipnum) {
                    arr[--k] = arr[i+1..j];
                    ordinals[k] = ordinals[j];
                }
                last = al[j = i];
            }
        }
        if (last != skipnum) {
            arr[--k] = arr[0..j];
            ordinals[k] = ordinals[j];
        }
    }
    return m_values(mkmapping(ordinals[k..], arr[k..]),0);
}

/* creator_file - Rumplemintz */
mixed creator_file(string object_name) {
  string *path;

  if (strstr(object_name,"//") >= 0 || member(object_name,'#') >= 0)
    return 0;

  path = explode(object_name,"/") - ({"","."});
  switch(sizeof(path) && path[0]) {
  case "open":
  case "ftp":
  case "log":
  case "newlib":
  case "oldlib":
    return 0;
  case "players":
    if (sizeof(path) < 3)
      return 0;
    return path[1];
  case "domains":
    if (sizeof(path) < 3)
      return 0;
    return capitalize(path[1]);
  default:
    return 1;
  }
  return 1;
}

string query_version() {
    return __VERSION__;
}

//---------------------------------------------------------------------------
string a_or_an(string phrase)
{
  phrase = delete_colour(phrase);
  return (is_vowel(phrase[0])?"an":"a");
}


/*************************************************************************/

#endif /* LDMud check */

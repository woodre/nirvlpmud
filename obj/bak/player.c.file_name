#pragma verbose_errors

inherit "/obj/player/nrpoints.c";

#if 0 /* Rumplemintz */
#ifdef __LDMUD__
inherit "/players/earwax/modify_command.c";
inherit "/obj/player/secure/files.c";
#endif /* LDMUD */
#endif /* 0 */

inherit "obj/user/cmd_hook";
inherit "/obj/player/dr/dirs.c";

inherit "/obj/living.c";
inherit "obj/user/channel";
inherit "/obj/wiz/snoop/play_lib";
inherit "/obj/player/bank.c";

/* Earwax's projects */
inherit "/obj/player/stats.c";
inherit "/obj/player/beta.c";

#include <security.h>
#include <ansi.h>

#include "/obj/lib/living/settings.h"
#include "/obj/play/follow/follow.c"
#include "/obj/user/one_chan.c"
#include "/closed/handshake.h"
#include "/obj/quest_pt.c"
#include "/obj/player/prego.c"
#include "/obj/monitor.c"

#include "/closed/verte/qt/play_inc.h"
#include "/obj/play/new_communicate.h"
#include "/obj/player/dr/misc.c"

#define TESTCHAR_D "/obj/user/testchar-d"
#define RUN_COMMAND_FILE "/bin/wiz/run_mod"

/* Static Variables */
static int autosave_counter, autoheal_counter;
static int pk_title_time;
static int whimpy_delay,noidlequit,is_interactive;
static int oldtreasure,oldexp;
static int inact,inacttwo,channelcount;
static string afk_message;
static object myself, soul;
static mixed *tellblock;
static string tellhistory,replyto;
static int tellhidx,privblk;
static string password2;
static int idlewarn,idletime;
static int power;
static int save_level;
static string it;
static int pc; /*password attempt count */
static string *player_ids;
static object *my_discon_box;
static string *blocking_pagers;
static status pageblock;
/* Why static?  Rumplemintz
static */
status testchar_var;
static object gob;
static int attack_count;
static string do_cmds;
static status do_pause;
static status prompt_revive;
/** Gnar 03/13/14 **/
static mixed *shop_inventory;
static int shop_page_no;

/* Non-Static Global Variables */
int nirvana_points;
string clan;
string sig;
string wkrm,hostname;
string ok_edit;
string mailaddr;
string saved_where;
string title;
string pretitle;
string password;
string spouse;
string race;
string al_title;
int PKGhostCounter;
int intoxicated;
int infuse, stuffed, soaked;	
int headache, max_headache;
string fight_area;
int mon,phys_at;
int no_spell;
string called_from_ip;
string msghome;
string description;
string guild_name;
string clan_name;
string clan_master;
string clan_file;
string lastime;  /*last login time */
int player_killing;
int invs_count;
int invs_flag;  /* are we invisible??? (players only) */
int new_pl_rest;
int muffled;
int treasure;	
string treasure_str;
string pwd;
status errormsgs;
int guild_rank, guild_exp;
string guild_file;
string home;
int ex_lv;
int qc; /* counter on quit attempts stop reboot jams -Bp */
int no_give;
string aprv;
string hint; /* password hint */
string *AnsiPref;
string old_last;
int wiz_soul_light;
string present_log, present_castle;
string *friends;

static int exp_login;
static int time_login;

#include "/closed/verte/super_secret_pass.h"
#include "/closed/verte/ansi_prefs.h"
#include "/room/tune.h"  /* for determining QPs */

add_age(x) { age += x; }
/* ======================================================================
 * Tox funs (fiddled with by illarion on 2014.02.21)
 * ======================================================================
 */
query_infuse() { return infuse; }
static add_infuse(arg) { infuse += arg; }
query_infuse_limit() { return INFUSE_LIMIT; }

query_soaked() { return soaked; }
void add_soaked(int i) {
  if(present("notsoak")) return 0;
  if(i < 0 && (-i > soaked /10)) 
    i = -soaked / 10;
  soaked += i;
  if (soaked < 0) soaked = 0;
}
drink_soft(strength) {
  if(present("notsoak")) return 0;
  if(strength > 0)
  if (soaked + strength > MAX_SOAK) {
    write("You can't possibly drink that much right now!\n" + 
      "You feel crosslegged enough as it is.\n");
    return 0;
  }
  soaked += strength * 2;
  if (soaked < 0)
    soaked = 0;
  if (soaked == 0)
    write("You feel a bit dry in the mouth.\n");
  return 1;
}

query_stuffed() { return stuffed; }
add_stuffed(i) {
  if(present("notstuff")) return 0;
  if(i < 0 && (-i > stuffed / 10)) 
    i = -stuffed /10;
  stuffed += i;
  if (stuffed < 0) stuffed = 0;
}
eat_food(strength) {
  if(present("notstuff")) return 0;
  if(strength > 0)
  if (stuffed + strength > MAX_STUFF) {
    write("This is much too rich for you right now! Perhaps something"+
      " lighter?\n");
    return 0;
  }
  stuffed += strength * 2;
  if(stuffed > MAX_STUFF && random(100) < 15) {
    write("You really shouldn't eat so much.\n");
    this_object()->add_phys_ate(3, random(2));
    return 1;
  }
  if (stuffed < 0)
    stuffed = 0;
  if (stuffed == 0)
    write("Your stomach makes a rumbling sound.\n");
  return 1;
}

drink_alcohol(strength) {
  if(present("notintox")) return 0;
  if(strength > 0)
    if (intoxicated > MAX_INTOX && strength > 0) {
        write("You fail to reach the drink with your mouth.\n");
	return 0;
    }
    add_intoxination(strength);
    if (intoxicated < 0) intoxicated = 0;
    if (intoxicated == 0)
	write("You are completely sober.\n");
    if (intoxicated > 0 && headache) {
	headache = 0;
	tell_object(myself, "Your head ache disappears.\n");
    }
    if (intoxicated > max_headache)
	max_headache = intoxicated;
    if (max_headache > 8)
	max_headache = 8;
    return 1;
}

query_intoxination() { return intoxicated; }
add_intoxination(i) {
  if(present("notintox")) return 0;
  intoxicated += i;
  if (intoxicated < 0) {
	  intoxicated = 0;
	  remove_call_out("intoxicate");
	  return;
  }
  if (intoxicated && find_call_out("intoxicate") == -1)
    call_out("intoxicate", 5 + random(56));
}

static intoxicate() {
  string cs, w;

  if (!intoxicated) return;
  call_out("intoxicate", 5 + random(56));
  
  switch(random(7)) {
    case 0 .. 2: return;
    case 3: cs = " hiccups.\n"; w = "You hiccup.\n"; break;
    case 4: cs = " seems to fall, but takes a step and recovers.\n"; w  = "You stumble.\n"; break;
    case 5: cs = " looks drunk.\n"; w = "You feel drunk.\n"; break;
    case 6: cs = " burps.\n"; w = "You burp.\n";
  }
  checked_say(cap_name + cs);
  write(w);
}

int query_max_intox()  { if(present("notintox")) return -100; return MAX_INTOX;    }
int query_max_soak()   { if(present("notsoak")) return -100;  return MAX_SOAK;     }
int query_max_stuff()  { if(present("notstuff")) return -100; return MAX_STUFF;    }
int query_max_infuse() { return INFUSE_LIMIT; }

/* ======================================================================
 * Support for 'do' command - used to be /closed/verte/qt/do/play_inc.h
 * ======================================================================
 */

void set_do_cmds(string x)  { do_cmds = x; }
void set_do_pause(status x) { do_pause= x; }

string query_do_cmds()      { return do_cmds; }
status query_do_pause()     { return do_pause; }

void score() { "/bin/play/_score.c"->cmd_score(0); }
void score2() { "/bin/play/_score2.c"->cmd_score2(0); }
/*
 * next funs called by hb 
 */

void
do_process_cmd_hook(string cmd)
{
     if(cmd && (cmd != "")) {
    tell_object(this_object(), "Doing: " + cmd + "...\n");
    command(cmd, this_object());
    }
}

void
process_do_cmd()
{
    if(stringp(do_cmds) && !do_pause)
    {
      string   cmd_to_process, remaining_cmds;

      if(sscanf(do_cmds, "%s,%s", cmd_to_process, remaining_cmds) == 2)
      {
        do_process_cmd_hook(cmd_to_process);
        do_cmds = remaining_cmds;
      }
      else
      {
        do_process_cmd_hook(do_cmds);
        do_cmds = 0;
      }
    }
}

/* ======================================================================
 * Logon functions
 * ======================================================================
 */
clear_password() {
  if(query_ip_name(this_player()) && (int)this_player()->query_level() >= GOD)
    password = 0;
}

static logon() {
  int i, s;
  int j;
  object *us;
  string blockmsg;
  enable_commands();

  write("\n");
#ifndef __LDMUD__ /* Rumplemintz - Use ACCESS.ALLOW instead of this */_
  blockmsg = call_other("obj/locklist","check_locklist", query_ip_number());
  /* 12/21/06 Earwax: removing this for now, no more chances tho */
  /*
  if (sscanf(query_ip_number(), "72.148%s", blockmsg))
  {
    write("No.\n");
    destruct(this_object());
    return;
  }
  */
  if(blockmsg) {
    write(blockmsg +"\n");
    destruct(this_object());
    return;
  }
#endif /* Bypass locklist on LD Driver */
  cat ("/WELCOME");
  write("\n");
  s = sizeof(us=users());
/* Changing this a bit per a player suggestion to count invis pk'ers as
   logged on players - Rumplemintz */
  while(s--) {
#if 0 /* Rumplemintz */
    if(us[s]->query_invis()) continue;
#else /* Don't count invis non-pkers, or invis wizards */
    if ((us[s]->query_invis() && !us[s]->query_pl_k()) ||
        (us[s]->query_invis() > 19)) continue;
#endif
    if(us[s]->query_level() <= 0) continue;
    if(us[s]->is_testchar()) continue;
    if(us[s]->query_level() <= 20) i ++;
    else j ++;
  }
  write("There are currently "+i+" players and "+j+" developers logged in.\n");
  write("Please use the guest name if you just want a look.\n\n");
  phys_at=allocate(6);
  tellblock=allocate(6);
  tellhistory=allocate(7);
  treasure_str=allocate(25);
  write("What is your name: ");
  sethost();
  input_to("logon2");
  call_out("timeout", 60);
  return 1;
}

shoutin () {
  int cexp,lvl,invs;
  string nom,wi;
  if(level > 0 && level < EXPLORE) {
    cexp=call_other("room/adv_guild", "check_level", level);
    add_alignment(0);
    if(experience < cexp) {
      call_other("room/adv_guild", "correct_level", this_object());
    }
    if (ex_lv) {
      cexp=call_other("room/exlv_guild", "check_level", ex_lv);
      if(experience < cexp) {
        call_other("room/exlv_guild", "correct_extra_level", this_object());
      }
    }
  }
  if(player_killing > 1) player_killing = player_killing - 2;
  add_ansi_pref("page", 0);
  add_ansi_pref("pk", 0);
  add_ansi_pref("title",0);
  add_ansi_pref("pretitle",0);
  lvl = this_player()->query_level();
  nom = capitalize(this_player()->query_name());
  invs = this_player()->query_invis();
  if(this_object()->is_testchar()) return 1;
  set_light(wiz_soul_light);
  if(level > 19 || invs > 18) return 1;
  if(lvl > 9999) {wi = "God";lvl = 0;}
  if(lvl > 19 && lvl < 9999) { wi = "Wizard"; lvl = 0; }
  if(lvl > 0) {
    chan_msg(nom + " ( player " + lvl + (ex_lv ? 
             ("+" + ex_lv) : "") + " ) has entered the game.\n", "msg");
    return 1;
  }
  else chan_msg(nom + " ( " + wi + " ) has entered the game.\n","msg");
  return 1;
}

shoutout() {
  int lvl,invs;
  string nom,wi;
  lvl = this_object()->query_level();
  nom = capitalize(this_object()->query_name());
  invs = this_object()->query_invis();
  if(this_object()->is_testchar()) return 1;
  if(level > 19 || invs > 18) return 1;
  if(lvl > 9999) {wi = "God";level = 0;}
  if(lvl > 19 && lvl < 9999) {wi = "Wizard";level = 0;}
  if(lvl > 0) {
    chan_msg(nom + " ( player " + lvl + (ex_lv ? 
             ("+" + ex_lv) : "") + " ) has left the game.\n", "msg");
    return 1; 
  }
  else if(wi)
    chan_msg(nom + " ( "+wi+" ) has left the game.\n", "msg");
  return 1;
}

static timeout() {
  write("\nTimeout\n");
  destruct(this_object());
}

object other_copy;
static try_throw_out(str) {
  object check_copy,ob;
  string blah1,blah,tmp_name;
  remove_call_out("timeout");
  if (str == "" || (str[0] != 'y' && str[0] != 'Y')) {
    write("Come back another time then!\n");
    see_if_other(1);
    destruct(this_object());
    return;
  }
  tmp_name = name;
  name = 0;
  check_copy = find_player(tmp_name);
  if (!check_copy)
    check_copy = find_player("ghost of " + tmp_name);
  name = tmp_name;
  if (!check_copy) {
    write("Something has gone wrong, please try again...\n");
    log_file("BAD_PLAYER", ctime()[4..15] + " " + ctime()[20..23] + " " + name +
      " money cloning method #2\n");
    see_if_other(1);
    destruct(this_object());
    return;
  }

  ob = environment(other_copy);
  remove_interactive(other_copy);
  log_file("ENTER", cap_name +" (throw)\n");
  if(!interactive(other_copy))
    move_player_to_start(ob);
  else {
    write("Other copy is still interactive, forcing disconnection.\n");
    write("Continue? (y/n) ");
    input_to("try_throw_out");
  }
}

static logon2(str) {
  string ajunk,bjunk;
  remove_call_out("timeout");
  call_out("timeout", 120);
  if (!str || str == "") {
    destruct(this_object());
    return;
  }
  if (sscanf(str, "GET /%s", ajunk) == 1)
  {
    "/bin/play/_wizes"->cmd_wizes("");
    "/bin/play/_who2"->cmd_who2(0);
    destruct(this_object());
    return;
  }
  if (name != "logon") {
    illegal_patch("logon2");
    destruct(this_object());
    return;
  }
  str = lower_case(str);
  if (!valid_name(str)) {
    input_to("logon2");
    write("Give name again: ");
    return;
  }
  if (restore_object("banish/" + str)) {
    write("That name is reserved.\n");
    write("Please use another if you wish to create a new character.\n");
    write("Please try again soon.\n");
    destruct(this_object());
    return;
  }
#ifndef __LDMUD__ /* Rumplemintz - just use banish... */
  if (restore_object("pfiles/dumbasses/" + str)) {
    write("Go away.\n");
    destruct(this_object());
    return;
  }
#endif
  if (restore_object("players/inactive_saved/"+str)) {
    log_file("INACTIVE", name + " Attempt " + query_ip_name(this_object()) +
             " (" + query_ip_number(this_object()) + ") " + ctime() + "\n");
    if(!password && !experience) {
      write("Your player file is no longer active.\n"+
        "write nirvana_lpmud@yahoo.com to be returned to active status.\n");
      destruct(this_object());
      return;
    }
    if(no_give > 1000 && time() - no_give < 1296000) {
      write("Inactivity must last MORE than 15 days.\n");
      write("Inactivity began at "+ctime(no_give)+"\n");
      write("Reactivation may occur after "+ctime(no_give+1296000)+"\n");
      write("Please try again later. write nirvana_lpmud@yahoo.com\n"+
            "if you have any questions.\n");
      destruct(this_object());
      return;
    }
    no_give = 0;
    write("Restoring from the inactive directory, Welcome Back!\n");
    inact = random(500);
    SET_HANDSHAKE(inact);
  }

  if(!inact)
    if (!restore_object("pfiles/" + extract(str,0,0) + "/" + str)) {
      write("New character.\n");
      if (query_ip_number(this_object()) == "216.206.81.158") {
        write("You can no longer create new characters from this address.\n");
        destruct(this_object());
        return;
      }

      mon = 1;
      new_pl_rest = 1;
      if (new_pl_rest) ResetStats();
    }
/* uncomment to lock game to wizards.
if(level < 21) {
      write("wizards only.\n");
     destruct(this_object());
    }
*/
  /* 05/15/06 Earwax: daemonized this: /obj/daemons/closed/ipcheck */
  if(level > 999) {
    string myip;
    myip = query_ip_number();
    if(!"/obj/daemons/closed/ipcheck"->check(myip, str)) {
      write("God and level 1000 access not allowed from your address.\n");
      destruct(this_object());
    }
  }

  name = str;
  see_if_other(2);
  dead = ghost;
  myself = this_player();
  soul = 0;
  mon = 1;
  /* Trying something. Fred 
  if(soul)
  destruct(soul);
  */
  if (query_invis(0) >= SOMEONE)
    cap_name = "Someone";
  else
    cap_name = capitalize(name);
  vis_name = capitalize(name); /* Rumplemintz */
  /* 03/20/06 Earwax: moved from call_out() to heart_beat() 
  if (level < EXPLORE)
    call_out("autosave", SAVE_INTERVAL);
  call_out("autoheal", INTERVAL_BETWEEN_HEALING);
  */
  sethost();
  local_weight = 0;
  armor_class = 0;
  name_of_weapon = 0;
  weapon_class = WEAPON_CLASS_OF_HANDS;

  if (level == -1)
    cat("/obj/msgs/new_player_passwd");
  
  write("Password: ");
  if (name == "guest") {
    write("(just CR) ");
  }
  if (level != -1)
    input_to("check_password", 1);
  else 
    input_to("new_password", 1);
  attacker_ob = 0;
  alt_attacker_ob = 0;
  save_level = level;
  level = 0;
  fight_area = 0;
  this_object()->testchar_check();
  if ("/room/prison.c"->query_prisoner())
    move_object(this_player(), "/room/prison");
  return;
}

/* ======================================================================
 * 
 * ======================================================================
 */

query_treasure()
{
  return treasure;
}
 
save_character(arg)
{
  int diffexp, difftreasure;
  if(arg != "silent" && oldtreasure && oldexp && level < EXPLORE) {
    diffexp = experience - oldexp;
        compute_treasure();
    difftreasure = treasure - oldtreasure;
    if(difftreasure < 5000) { write("Ok.\n"); return 1;}
    if(diffexp < 1000 && level > 11 ) { write("Ok.\n"); return 1;}
    if(diffexp < 100 && level > 3  ) { write("Ok.\n"); return 1;}
    if(diffexp < 5000 && level > 17) { write("Ok.\n"); return 1;}
  }
  oldtreasure = treasure;
  oldexp = experience;
  save_me();
  if (arg != "silent")
    write("Ok.\n");
  return 1;
}

recalc_carry() {
  object ob, next_ob;
  local_weight = 0;
  if (myself)
  ob = first_inventory(myself);
  while (ob) {
    next_ob = next_inventory(ob);
    local_weight += call_other(ob, "query_weight");
    ob = next_ob;
  }
}

reset(arg) {
  if (!arg)
  {
    if(!channel_names)
    channel_names = ({"gossip","msg","risque","newbie","shout",});
    if(!atrbr)
      atrbr = ({charisma,dexterity,intelligence,luck,magic_aptitude,piety,stamina,stealth,strength,will_power,});
    if(!AnsiPref)
    AnsiPref = ({ "page", 0, "tell", 0, "gossip", 0, "risque", 0, "junk", 0, "babble", 0, "newbie", 0, "msg", 0, "announce", 0 });
    if(!saved_aliases)   saved_aliases = ({ });
    if(!saved_nicknames) saved_nicknames = ({ });
    if(!nicknames)
    nicknames = ([ ]);
     if(!aliases)
    aliases = ([ ]);
    setup_stats();
  }
  set_max_spell();
  fight_area = idlewarn = 0;
  time_login = time();
  noidlequit = 1;
  if(!blocking_pagers) blocking_pagers = ({ });
  if(!player_ids) player_ids = ({ });
  idletime = IDLELIMIT;

  set_max_hp();
  if (name){
    if (head_armor==capitalize(name)) head_armor =0;
  }
  if (!quest_point) 
    recalc_quest();
  if (arg) {
    if(this_object()->query_mounted()) {
      object mm;
      mm=this_object()->query_mounted();
      if(environment(this_object()) && 
        !present(mm, environment(this_object()))) {
      command("dismount "+mm->query_name());
      this_object()->clear_mounted();
      }
    }
    if (level >= EXPLORE) return;
    if (name == NAME_OF_GHOST) {
      ghost = 1;
      msgin = "drifts around";
      msgout = "blows";
    } else {
      ghost = 0;
      dead = 0;
      msgin = "arrives";
      msgout = "leaves";
    }
    recalc_carry();	
    return;
    }
    if (myself)
      return;
    if (creator(this_object())) {
      illegal_patch("cloned player.c");
      destruct(this_object());
      return;
    }
    set_heart_beat(1);
    level = -1;
    name = "logon";
    cap_name = "Logon";
    vis_name = "Logon"; /* Rumplemintz */
    msgin = "arrives"; msgout = "leaves";
    mmsgin = "arrives in a puff of smoke";
    mmsgout = "disappears in a puff of smoke";
    msghome = "goes home";
    title = "the title-less";
    al_title = "neutral";
    treasure = 0;
    gender = 0;
    fight_area = 0;
}

query_spell_point() { 
  if(this_object()->checkNM()) return -200;
  return spell_points;
}

short() {
  string tmp_pre;
  object ob;
  object pt_ob,mount;
  string st_desc,ab,bc,pt_nom,title_tmp,tlcol;
  int i;

  sscanf(file_name(this_object()), "%s#%s",ab,bc);
#if 0 /* Rumplemintz */
#ifdef __LDMUD__
  if (ab[0] == "/") ab == ab[1..];
#endif
#endif
  if(ab!="obj/player") {
    illegal_patch("cloned player.c short");
    destruct(this_object());
    return;
  }

  pt_nom = 0;
  pt_ob = present("party object", this_object());
  if (pt_ob)
    pt_nom = call_other(pt_ob, "extra_short", 0);
  i = query_invis();
  mount = this_object()->query_mounted();
  if (this_player()) {
      i = query_invis(this_player()->query_level(),this_player()->query_extra_level());
  }
  if (i >= NO_SHORT)
    return 0;
  title_tmp = this_object()->query_title();
  if(query_frog()) title_tmp = "the Frog";
    
  st_desc = cap_name;
  if(title_tmp != "") st_desc += ((delete_colour(title_tmp)[0] == ',') ? "" : " ");
  st_desc += title_tmp;
  st_desc += NORM; /* no more bleeding titles */
  if(pretitle) {
    st_desc = this_object()->query_pretitle()+" "+st_desc;
  }
  if(pt_ob=present("player_short_object",this_object()))
    st_desc=(string)pt_ob->query_player_short();
  if ((this_player() && this_player() == this_object()) ||
      level > 21 ||
      guild_name == "mage" || guild_name == "bloodfist" ||
      guild_name == "doppleganger")
    st_desc += " ("+query_al_title()+")";
  st_desc += 
    (is_interactive?"":" (disconnected)");
  if (i < 0) 
    st_desc=(st_desc+" ("+query_invis()+")"+
      (is_interactive ? "": " (disconnected)"));
  if (mount)
    st_desc = st_desc +  " mounted on " + mount->on_what();
  if (pt_ob && pt_nom != 0)
    st_desc = st_desc + " " + pt_nom;
  if(clan_name) {
    st_desc = st_desc+" <"+capitalize(clan_name)+" Clan>";
  }
  if(tmp_pre = (string)this_object()->query_testchar_owner())
    st_desc = "["+HIR+capitalize(tmp_pre)+" Test Character"+NORM+"] "+st_desc;
  if (ghost) 
    st_desc = "ghost of " + cap_name + 
      (is_interactive ? "" : " (disconnected)");
  if(afk_message)
    st_desc+=" (afk)";
  if("/pa/admin/pa-daemon"->query_name(name))
  {
    st_desc+= " ["+BOLD+"PLAYER AFFAIRS"+NORM+"]";
  }
  if(present("newbie_helper",this_object()))
    st_desc += " ("+HIB+"Newbie Helper"+NORM+")"
  ;
  if(player_killing && level < 21) st_desc = HIR+"[PK]"+NORM+" "+st_desc;
  if(this_player() && (this_player() != this_object()) && (ob = present("sight_short_modifier", this_player())))
  {
    return (string)ob->modify_short(st_desc);
  }
  if(present("essence of nirvana", this_object())) {
    st_desc = GRN+"<)"+NORM+st_desc+GRN+"(>"+NORM;
  }
  return st_desc;
}  

/* ======================================================================
 * 
 * ======================================================================
 */

long() {
  string a_or_an, racetmp, tmptmp;
  int me_me;
  
  me_me = (this_object() == this_player() ? 1 : 0);
#if 0 /* Rumplemintz */
  write(short() + " (" + gender + ")" + ".\n");
#else
  if (short() )
    write(short());
  else
    write("Invisible Player");
  write(" (" + gender + ")" + ".\n");
#endif /* 0 */
  
#if 0 /* Rumplemintz */
  if (call_other(this_player(),"query_level") >= 20) {
    if (level >= GOD) write("==> god\n");
    else if (level >= ELDER) write("==> elder wizard\n");
    else if (level >= SENIOR) write ("==> senior wizard\n");
    else if (level > EXPLORE) write("==> wizard\n");
    else write("==> apprentice wizard\n");
  }
#else
  switch(level) {
  case 1..19:
    write("");
    break;
  case 20:
    write("==> apprentice wizard\n");
    break;
  case 21..44:
    write("==> fledgeling wizard\n");
    break;
  case 45..99:
    write("==> wizard\n");
    break;
  case 100..999:
    write("==> senior wizard\n");
    break;
  case 1000..4999:
    write("==> elder wizard\n");
    break;
  case 5000..9999:
    write("==> arch wizard\n");
    break;
  case 10000..99999:
    write("==> demi god\n");
    break;
  default:
    write("==> god\n");
    break;
  }
#endif /* 0 */
  
  if(description) write(cap_name + " "+description+"\n");
  
  racetmp = race;
  if(frog) racetmp = "Frog";
  tmptmp = racetmp;
  racetmp = lower_case(delete_colour(racetmp));
  if(racetmp[0] == 'a' || racetmp[0] == 'e' || racetmp[0] == 'i' 
  || racetmp[0] == 'o' || racetmp[0] == 'u')
    a_or_an = 1;
  racetmp = tmptmp;
  write((this_player()==this_object()?"You are":cap_name+" is") + (a_or_an ? " an":" a")+" "+racetmp+", "+phys_at[1]+" feet "+phys_at[2]+" inches tall, "+phys_at[3]+" lbs.\n");

  if(pregnancy) 
    preggers_long(me_me, phys_at[3], (age-pregnancy));
  if (player_killing) 
    write(RED+(me_me?"You":cap_name)+" can fight other players.\n"+NORM);
  if (ghost || frog) 
    return;
	write((me_me? "You are": cap_name + " is"));
	
	if (hit_point < max_hp/10) write(" in very bad shape.\n");
	else if (hit_point < max_hp/5) write(" in bad shape.\n");
  else if (hit_point < max_hp/2) write(" somewhat hurt.\n");
  else if (hit_point < max_hp * 9 / 10) write(" slightly hurt.\n");
  else write(" in good shape.\n");
}

/* ======================================================================
 * 
 * ======================================================================
 */
status player_id_check(string arg) {return (member_array(arg, player_ids) > -1); }
 
status id(string str) {
  int i;

  if (query_invis())
  {
    if (this_player())
      i = (int)query_invis((int)this_player()->query_level());
    if (i < 0 && (str == name) || (player_id_check(str)))
      return 1;
    if (i >= NO_ID)
      return 0;
  }
  return ( str == name || str == PLAYER_ID || player_id_check(str)
  || (ghost && str == "ghost of " + name) );
}


query_title() {
  string tlcol;
  return ((tlcol=get_ansi_pref("title")) ? tlcol+title+NORM : title);
}
query_pretitle() {
  string tlcol;
  
  if(!pretitle || pretitle == "") return 0;
  return ((tlcol=get_ansi_pref("pretitle")) != 0 ? tlcol+pretitle+NORM : pretitle);
}

void set_pretitle(string str){
  pretitle=str;
}


set_pk_title_time(t) { pk_title_time = t; }

set_title(t) {
  if(pk_title_time > time()) {
    write("You cannot set your title at this time.\n");
    write("You must wait "+(pk_title_time - time())+" seconds.\n");
    return 1;
  }
  if (t == "|") {
    write("Clearing your title.\n");
    title = "";
    return 1;
  }
  if (!t) {
	  write("Your title is " + title + ".\n");
	  return 1;
  }
  title = t;
  return 1;
}

set_level(lev) {
  if (lev > CREATE || lev < level && level >= EXPLORE)
    return illegal_patch("set_level");
  level = lev;
/*
#ifdef __LDMUD__
  db_get_rs("update players set level=" + level + " where name='" + name + "'");
#endif
*/
  set_max_hp();
  set_max_spell();
    
/*
#ifndef __LDMUD__
*/
  if (level >= EXPLORE) {
    tell_object(myself, "Adding wizard commands...\n");
	  soul("on");
  }
  if (level >= EXPLORE && soul)
    call_other(soul,"update",1);
/*
#endif
*/

  log_file("ADVANCE", ctime() + " " +cap_name+" advanced to level "+level+"\n");
  save_me();
}

destruct_inventory() {
  object next_ob,ob;

  ob = first_inventory(this_object());
  while(ob) {
  	next_ob = next_inventory(ob);
    if (!call_other(ob, "id", "soul") && !call_other(ob,"id","wiz_soul"))
	    destruct(ob);
	  ob = next_ob;
  }
}

set_wiz_level(string key){
    string lev;
    int new_level;
    string verb;

    if (!interactive(this_player())) {
        write("Sorry, but you are not a player.\n");
        return 0;
    }

    if(file_name(previous_object()) != "bin/wiz/_promote")
    {
      write("Sorry, you can't do that.\n");
      return 0;
    } 
 
    /*
    lev = call_other(call_other(this_player(), "query_soul"),
	"get_handshake",key);
    */
    sscanf(key,"%d",new_level);
    if(level > new_level) verb = "demoted";
    else verb = "promoted";
    level = new_level;
    tell_object(myself,"You were "+verb+" to level " + key + " by " +

        capitalize(call_other(this_player(),"query_real_name")) + ".\n");
    tell_object(myself,"Remember to read the help files to determine your new abilities.\n");
    log_file("PROMOTIONS", "["+ctime()[4..15]+" "+ctime()[20..23]+"] "+
                           capitalize(name)+" was "+verb+" to Level "+key+
        " by " + capitalize(this_player()->query_real_name()) +
	".\n");
/*
#ifndef __LDMUD__
*/
    soul("off");
/*
#endif
*/
    save_me();
  if(soul)
    destruct(soul);
/*
#ifndef __LDMUD
*/
    soul("on");
/*
#endif
*/
    return 1;
}

do_quit(str) {
  if(str) return 0;
  if (file_size("/players/" + this_player()->query_real_name() +
    "/logout") < 1) 
    return quit();
  write("Do you wish to execute your logout file(y/N)? ");
  input_to("do_quit2");
  return 1;
}

do_quit2(str) {
  if (lower_case(str) == "y")
    RUN_COMMAND_FILE->run_command_file("/players/" + this_object()->query_real_name() +
      "/logout", "quit");
  return quit();
}

quit() {
    object army, ob;
    if(inact) inacttwo = inact;
    qc += 1;
    if(!this_object()) return;
    ob = first_inventory(this_object());
    while(ob) {
      if (ob->queryKept())
        ob->deShadow();
      ob = next_inventory(ob);
    }
    if(this_object()->query_mounted()) {
      object mm;
      mm=this_object()->query_mounted();
      if(environment())
      move_object(mm,environment(this_object()));
	      command("dismount "+mm->query_name());
    }
    power = 0;
    if(qc < 5) {
    if (level < EXPLORE)
    {
     army = present("armageddon",find_object("room/church"));
     if(army) 
       if(army->query_goingdown()) 
         cross_reboot_save();
	drop_all(1);
    }
    if(!stringp(lastime)) lastime = "UNKNOWN";
    if(strlen(lastime) > 70) lastime ="UNKNOWN";
    if(query_invis() < 19)
    {
    lastime = lastime + " to " + ctime()[4..15] + ctime()[19..24];
   }
    clear_followers();
    save_me();
    shoutout();
    }
    if(qc > 4) save_me();
    destruct_inventory();
    if (level >= EXPLORE) { write("Inventory destructed.\n");
       rm("/log/"+this_object()->query_real_name()); }
    write("Saving "); write(capitalize(name)); write(".\n");
    checked_say(cap_name + " left the game.\n");
    log_file("ENTER", ctime()[4..15]+" "+ctime()[20..23]+" "+name+" exit "+experience +
             " ep, " + money + " g. "+called_from_ip+"\n");
    if(inact) {
      no_give = time();
      save_object("players/inactive_saved/"+name);
      inacttwo = 0;
      rm("/pfiles/"+extract(name,0,0)+"/"+name+".o");
    }
    destruct(this_object());
    return 1;
}

valid_attack(ob) {
  int their_level, can_attack;
  object here,here2;
  
  if(name=="guest" && !ob->query_npc()) return 0;    
  if(this_player() && (ob == this_player())) return 0;
  if(environment(this_object())->query_no_fight()) {
    write("Fighting is NOT allowed to begin here.\n");
    return 0;
  }
 if(this_player()) /* verte */
  if(this_player()->query_guild_name() == "rangers" &&
     !ob->is_player() && ob->query_alignment() > 10)
  {
    write("You can not bring yourself to attack that righteous being.\n");
    return 0;
  }
  if(call_other(ob, "is_player") && !call_other(ob, "query_interactive")) {
    write("You cannot attack disconnected players.\n");
    return 0;
  }
  /*  Leave code in for future beta use - Fred
  if (ob->query_guild_name() == "Rogue") {
    write("That player is beta testing a PK guild.  Please wait until\n"+
          "beta testing is over.\n");
    return 0;
  }
  if (this_player()->query_guild_name() == "Rogue" && ob->is_player()) {
    write("You are beta testing, no PK during this phase.\n");
    return 0;
  }
  */

  /* Put these as close to the top as possible, reduce lag -Bp */
  /* If we're already fighting them, then it must be OK. */
  if (ob == attacker_ob || ob == alt_attacker_ob) return 1;
  /* They can always attack NPCs */
  if (call_other(ob, "query_npc")) return 1;

  if (ob->is_player() &&
      environment()->query_no_pk()) {
    write("PK is NOT allowed to begin here.\n");
    return 0;
   }
  if((int)ob->query_guild_name()=="Nosferatu" && guild_name=="Nosferatu") {
    return 1;
  }
  if (call_other(ob, "is_player")) {
    if (call_other(ob, "query_level", 0) > 19) {
      write("You can't attack a wizard!\n");
      tell_object(ob, name+" tried to attack you.\n");
      return 0;
    }
    if (call_other(this_object(), "query_level", 0) > 19) {
      write("Wizards cannot attack players!\n");
      return 0;
    }
    their_level = ob->query_level();
    if(their_level < 8 && level - their_level > 3) {
      write("Pick on someone your own size.\n");
      return 0;
   }
   if(level < 8 && their_level - level > 3) {
     write("You shouldn't be picking fights like that.\n");
     return 0;
   }
  }
  here=environment(this_object());
  here2=environment(ob);
  if(fight_area && ob->query_fight_area() && fight_area == file_name(here)) {
    if(this_object()->query_level() > 2 && ob->query_level() > 2) 
    return 1;
  }
  if(ob->query_pl_k() > 1 || this_object()->query_pl_k() > 1) {
    if(here2->query_spar_area() && here->query_spar_area()) return 1;
    write("One or both pk flags are set to spar.This is not a sparing area.\n");
    return 0;
    } 
/* TODO: Add in logging here to resolve PK disputes.  Thinking of just
         dumping both player objects to get all of the set variables, such
         as level, xp, invis, environment, etc... - then cloning a logger
         to log all commands, also log all changes in hp/sp - must delete
         the logger after - Rumplemintz
*/
  if(ob->query_pl_k() && this_object()->query_pl_k() && 
    this_object()->query_level() > 2 && ob->query_level() > 2)
    return 1;
  
  return 0;
}

#if 0 /* Just put the code in.. no need for another include here - Rump */ 
#include "/obj/player/dr/communicate_fun.c"
#else
communicate(str) {
  if (!str) {
    write("Say what?\n");
    return 1;
  }
  str = format(str, 60);
  if (ghost) {
    say(short() + " says: " + str + ".\n");
    if (brief == 1)
      write("Ok.\n");
    else
      write("You say: " + str + "\n");
    return 1;
  }
#if 0 /* Rumplemintz - check for overload before using variable */
  say(cap_name + " says: " + str + "\n");
#else
  say(this_object()->query_name() + " says: " + str + "\n");
#endif
  if (brief == 1)
    write("Ok.\n");
  else
    write("You say: " + str + "\n");
  return 1;
}
#endif /* 0 */

static autosave() {
    if (brief != 1)
	write("\nAutosaving character...\n");
    if (idlewarn && is_interactive && query_idle(this_object()) < IDLELIMIT) 
       idlewarn = 0;
    if(call_other("room/prison", "query_locked", name)) { 
    write("You should be in prison, back you go.\n");
    say(cap_name+" is sucked into a blue light beam back to the prison.\n");
    move_object(this_object(), "room/prison");
    }
    save_me();
}

/* hp_regen_object & sp_regen_object code by verte, recoded by earwax */

static autoheal() {
  int x, ack;
  object regen_ob,ob;
    
  if (headache && !(--headache)) /* Earwax */
    tell_object(myself, "You no longer have a head ache.\n");
      
  if(attacker_ob) return;
  x=2; ack = 0;
  if( regen_ob = present("hp_regen_object", this_object()) ) {
    while(regen_ob) {
      x += (int)regen_ob->query_hp_regen();      
      ack++;
      regen_ob = present("hp_regen_object "+ack, this_object());
    }
    ack = 0;
  }
  if(!query_attack()) {
    hit_point += intoxicated ? (12*x) : x; 
    if (hit_point > max_hp)
      hit_point = max_hp;
  }
  x=2; ack = 0;
  if( regen_ob = present("sp_regen_object", this_object()) ) {
    while(regen_ob) {
      x += (int)regen_ob->query_sp_regen();      
      ack++;
      regen_ob = present("sp_regen_object "+ack, this_object());
    }
    ack = 0;
  }    
    
  if(!query_attack()) {
    spell_points += intoxicated ? (12*x) : x;
    if(spell_points > max_spell)
      spell_points=max_spell;
  }
        
  if (intoxicated && !(--intoxicated)) { /* 05/15/06 Earwax */
    headache = max_headache; max_headache = 0;
    tell_object(myself, "You suddenly without reason get a bad head ache.\n");
    if ((hit_point -= 3) < 0) hit_point = 0;
  }
   /* 03/20/06 Earwax: moved callout to heart_beat() */
}

heart_beat() {
  int att_mhp,timetoboot,myidletime;
  
  if(!this_object()) return;
  if(interactive(this_object()))
    myidletime = query_idle(this_object());
  else
    myidletime = 2200;
  if (!afk_message && interactive(this_object())) {
  /* 07/12/07 Earwax: Added this */
  np_age++;
  if(name == "earwax" && np_age >= 900) write(HIC+ctime()+": Point added.\n"+NORM);
  if (np_age >= 900) { nrpoints++; totalpoints++; np_age -= 900; }

  if(myidletime > 600 && (!this_object()->query_afk_message()))
    command("afk idle", this_object());
  }
  if (!interactive(this_object()) && is_interactive) 
  {
    say(capitalize(name)+" just disconnected.\n");
    /* Stop cheaters with treasure -Bp */
    timetoboot=call_other("obj/time_check","discon_check",0);
    if (timetoboot > 900)
      call_out("discon_quit", 900);
    else if(timetoboot > 200)
      call_out("discon_quit",timetoboot-100);
    else if(timetoboot > 15)
      call_out("discon_quit",timetoboot-8);
    else
    {
      discon_quit();
      return;
    }
  }
  
  if(!this_object()) return;
  is_interactive = interactive(this_object());
  channelcount = attack_count = 0;
  set_max_spell();
  set_max_hp();
  if(PKGhostCounter && !(PKGhostCounter -=2))
    tell_object(this_object(), "\nYou may now revive from your incorporeal form.\n\n");
  if(ghost) {
    if(prompt_revive) {
      prompt_revive = 0;
      remove_ghost();
    }  
    return;
  }
  if (is_interactive) 
  {
    if(myidletime < IDLELIMIT+300) 
    {
      if(name != "vertebraker")
        age += 1;
      if (alignment != 0)
        alignment += (alignment > 0 ? -1 : 1);
    }

    infuse = (infuse > 0 ? infuse - (1+random(3)) : 0);
    
    if (attacker_ob)
    {
      if (stuffed > 0 && !random(3)) stuffed--;
      if (soaked  > 0 && !random(3)) soaked--;
    }
    else
    {
      if (stuffed > 0) stuffed -= 1+random(3);
      if (soaked > 0)  soaked  -= 1+random(3);
    }
  }

/* This is in an include until I go about daemonizing it -
 * it REALLY needs to be yanked from heartbeat code 
 * Plus with attribs and races going in, physical attributes
 * will change. - Earwax
 */
#if 0
#include "/obj/player/prego_hb.c"
#else
  /* Following code from /obj/player/prego_hb.c */
  if (pregnancy && myidletime < 2100) {
  /* hard coded number because separating broke it. -Bp was:
     if (pregnancy && myidletime < idletime + 300) {
   */
    int pregtmp;
 
    pregtmp = age - pregnancy;
    if (pregtmp == 2000) add_phys_at(3,5+random(kc()));
    if (pregtmp == 3000) add_phys_at(3,random(5)+random(kc()));
    if (pregtmp == 4000) add_phys_at(3,2+random(4)+random(kc()));
    if (pregtmp == 6000) add_phys_at(3,2+random(4)+random(kc()));
    if (pregtmp == 8000) add_phys_at(3,2+random(4)+random(kc()));
    if (pregtmp == 10000) add_phys_at(3,1+random(10)+random(kc()));
    if (pregtmp == 12000) add_phys_at(3,3+random(8)+random(kc()));
    if (pregtmp == 14000) add_phys_at(3,2+random(8)+random(kc()));
    if (pregtmp == 15500) add_phys_at(3,1+random(8)+random(kc()));
    if (pregtmp == 16500) add_phys_at(3,1+random(8)+random(kc()));
    if (pregtmp == 17500) add_phys_at(3,1+random(8)+random(kc()));
    if (pregtmp == 18500) add_phys_at(3,1+random(8)+random(kc()));
    if (pregtmp < 3000 && pregtmp > 500) {
      if (random(4000) < 3 || phys_at[4]==4001) {
        write("You feel sick, like you are going to puke.\n");
        if (phys_at[4] > 4000) phys_at[4]=0;
        add_phys_at(3, -random(3));
        if (random(100) < 10) {
          write("You bend over and puke.\n");
          say(cap_name + " doubles over and pukes.\n");
        }
      }
      if (random(5000) < 3) {
        write("You feel a strange hunger for food.\n");
      }
    }
    if (pregtmp > 1000 && pregtmp < 18000) {
      object bbb;

      if (random(9000) < 3 || phys_at[4]==4004) {
        int rrx;

        rrx = random(3);
        if (phys_at[4] > 4000) phys_at[4]=0;
        if (rrx == 0)
          tell_object(this_object(),
                      "You have a strange craving for peanut butter and " +
                      "hotdog sandwiches.\n");
        if (rrx == 1)
          tell_object(this_object(),
                      "You have a strange craving for pickles and ice " +
                      "cream.\n");
        if (rrx == 2)
          tell_object(this_object(), "Your fee feel swollen.\n");
      }
      if (random(8200) < 2 || phys_at[4]==4002) {
        tell_object(this_object(), "Your breasts feel heavier and larger.\n");
        if (phys_at[4] > 4000) phys_at[4]=0;
          say(cap_name + " wiggles uncomfortably as though her top is too " +
              "tight.\n");
        bbb = present("boobs", this_object());
        if (bbb) {
          bbb->add_cup(1);
          bbb->add_bust(1);
        }
      }
    }
    if (pregtmp > 12000) {
      if (random(25000) < 40 || phys_at[4]==4003) {
        if(phys_at[4] > 4000) phys_at[4]=0;
        tell_object(this_object(),"You feel the baby kick inside you.\n");
        say(cap_name + " jumps up as though something startled her.\n");
      }
    }
    if (pregtmp > 11000) {
      if (random(29000) < 40 || phys_at[4]==4004) {
        if(phys_at[4] > 4000) phys_at[4]=0;
        tell_object(this_object(),
                    "You suddenly need to pee... really, really bad.\n");
      }
    }
    if (pregtmp > 15840) {
      if (random(1000) < 20)
        tell_object(this_object(), "You feel labor pains.\n");
    }
    if (pregtmp > 16200 + random(500))
      if (random(900000) < pregtmp && phys_at[4]!=5001)
        child_birth();
  }
#endif /* prego_hb code */
             
  already_fight = 0;
  if(soaked < 0) soaked = 0;
  if(stuffed < 0) stuffed = 0;
  
  if (attacker_ob)
  {
    attack();
    COMBATD->add_combat_time(name);
    dam_taken_this_round=0;
   
    if(attacker_ob) 
    {
      if (whimpy && hit_point < max_hp*whimpy/100) 
      {
        if(whimpy_delay) { whimpy_delay = 0; run_away(); }
        else whimpy_delay = 1;
      }
      if (mon) print_monitor();
    }
  }
  else 
    dam_taken_this_round = 0;
    
  process_do_cmd();
  
  if(!noidlequit) {
    if (!idlewarn && is_interactive && myidletime > idletime) {
      write("You have been idle for "+idletime/60+" minutes. You will be logged off in "+ 
        "5 minutes.\n");
      idlewarn = 1;
    }
    if(idlewarn && is_interactive && myidletime < idletime) 
      idlewarn = 0;
    if(is_interactive && myidletime > idletime+300) {
      tell_object(this_object(), "Idle too long.....\n");
      if (level > EXPLORE) write(ctime()+"\n");
      log_file("ENTER", name + " idle quit ");
      call_other(this_object(), "discon_quit", 0);
    }
  }
  /* 03/20/06 Earwax: moved these to heart_beat() rather than call_out() */
  if (level < EXPLORE) {
    if ((autosave_counter += 2) >= SAVE_INTERVAL) {
      autosave_counter = 0;
      autosave();
    }
    if ((autoheal_counter += 2) >= INTERVAL_BETWEEN_HEALING) {
      autoheal_counter = 0;
      autoheal();
    }
  }
}

void add_alignment(int a) { /* 05/11/06 Earwax: recoded some of this */
  if (!a) return;
  
  if(this_player() && this_player()->is_player() 
  && (int)this_player()->query_level() > EXPLORE 
  && (int)this_player()->query_level() < GOD)
    return;

  alignment = alignment - (alignment*2/(30-level)) + a;
  
  if(alignment > CAP_GOOD_ALIGN) alignment = CAP_GOOD_ALIGN;
  if(alignment < CAP_EVIL_ALIGN) alignment = CAP_EVIL_ALIGN;
  
  if (alignment > ALIGN_WHITE_LORD) 
	  al_title = "white lord";
  else if (alignment > ALIGN_PALADIN) 
	  al_title = "paladin";
  else if (alignment > ALIGN_CRUSADER)
	  al_title = "crusader";
  else if (alignment > ALIGN_GOOD) 
  	al_title = "good";
	else if (alignment > ALIGN_HONORABLE) 
  	al_title = "honorable";
	else if (alignment > ALIGN_NEUTRAL) 
  	al_title = "neutral";
	else if (alignment > ALIGN_MALICIOUS)
  	al_title = "malicious";
	else if (alignment > ALIGN_EVIL) 
  	al_title = "evil";
	else if (alignment > ALIGN_INFAMOUS)
  	al_title = "infamous";
	else if (alignment > ALIGN_BLACK_KNIGHT) 
		al_title = "black knight";
  else
    al_title = "lord of evil";
}

status test_dark() { /* 05/11/06 Earwax: recoded this */
  if (!this_player()) return (set_light(0) > 0 ? 0 : 1);
  if(present("black_willow_object", this_object()))
  {
    if(set_light(0) > 0) return 1;
    else return 0;
  }
  if (set_light(0) > 0 || present("dark_sight_object", this_player()))
    return 0;
  if (level > SENIOR) {
    write("But you may still see...\n");
    return 0;
  }
  return 1;
}

query_weight() { return 80; }

add_weight(w) {
    int max;

  if (level == 1)
    max = level + 6 + strength/2;
  else 
    max = level + (strength <= 20 ? 5 + strength/5 : 10 + (strength-20)/5);
  if(ex_lv) max += (ex_lv / 4);
  if (frog)  max /=  2;
  if (w + local_weight > max || w + local_weight < 0)
	  return 0;
  local_weight += w;
  return 1;
}

varargs int look(string str, status flag) { 
  if(this_object() != this_player()) {
    write((string)call_other(environment(this_object()), "long")); write("\n");
  } else 
  return (int)"/bin/play/_look"->cmd_look(str, flag);
}
glance() { return "/bin/play/_look"->cmd_look(0, 1); }

static check_password(p) {
  if (password == 0 && name != "guest")
    write("You have no password! Set it with the 'password' cmd.\n");
  else if (name != "guest" && (crypt(p,extract(password,0,1)) != password)) {
    if (p != "hint") write("Wrong password!\n");
    if (p != "hint" && hint && pc < 2) write("Try 'hint' if you forgot.\n");
    if(p == "hint") {
      if (save_level < EXPLORE && hint) write("Password hint: "+hint+"\n");
      if (save_level < EXPLORE && !hint) write("No hint set.\n");
      if (save_level >= EXPLORE) write("No hints for wizards, sorry.\n");
    }
    see_if_other(1);
    pc += 1;
    if(pc > 2)
      destruct(myself);
    write("Password: ");
    input_to("check_password", 1);
    return;
  }
  if(inact) {
    save_me(3);
    rm("/players/inactive_saved/"+name+".o");
    log_file("INACTIVE",name+" returned from inactive. \n");
    inact = 0;
  }   

  write("\n");
  level = save_level;
  add_commands();
  if(soul)
    destruct(soul);
  soul("on");
  while(remove_call_out("timeout") != -1);
    init_channels();
  login_checks();
  if (query_invis() < 19)
  {
    string temp;

    if (level != 19) temp = level + "";
    else temp = level + "+" + ex_lv;

    "/daemons/logins"->add_entry(name, temp);
  }
  if (!mailaddr || mailaddr == "")
  {
    write("Please enter your email or web page address (or 'none'): ");
    new_pl_rest = 1;
    input_to("getmailaddr");
    return;
  }
  if (!hint || hint == "") {
    if (level < EXPLORE ) {
      write("Please enter a password reminder hint.\n");
      write("Please note anyone may view it.\nHint: ");
      new_pl_rest = 1;
      pc = 987;
      input_to("gethint");
      return;
    }
  }
  
  if(saved_where) {
    write("Return to previous location? ");
    call_out("timeout",60);
    input_to("prevloc");
    return;
  }
  if(!gender || !phys_at[1] || !phys_at[3]) {
    write("Please select a gender, either male or female: ");
    new_pl_rest=1;
    input_to("new_gender");
  } 
  else {
    move_player_to_start(0);
  }
}

/*
 * Give a new password to a player.
 */
static new_password(p) {
    if (this_player() != this_object()) return 0;
    if (!p || p == "") {
        write("You have aborted the character creation process.\n");
	write("Try again another time then.\n");
	destruct(myself);
	return;
    }
    if (strlen(p) < 6) {
        write("The password must be at least 6 characters long.\n");
	write("Password: ");
	input_to("new_password", 1);
	return;
    }
    if (password == 0) {
	password = p;
	write("Password: (again) ");
	input_to("new_password", 1);
	return;
    }
    if (password != p) {
	write("You changed !\n");
        cat("/obj/msgs/passwd_not_match");
	destruct(myself);
	return;
    }
    password = crypt(password,0);
    call_other("room/adv_guild", "advance", 0);
    hit_point = max_hp;
    add_commands();
  init_channels();
    write("\n");
    cat("/obj/msgs/hint");
    write("Hint: ");
    input_to("getnewhint");
}
getnewhint(phint) {
    hint = phint;
    cat("/obj/msgs/gender");
    write("Please select a gender, either male or female: ");
    input_to("new_gender");
}

static new_gender(str) {
    str = lower_case(str);
    if (str == "creature" || str == "male" || str == "female") {
      gender = str;
      cat("/obj/msgs/race");
      write("Race:");  
      input_to("new_race");
    } else {
	write("You must select either male or female: ");
	input_to("new_gender");
    }
}

/* 05/11/06 Earwax: Did some formatting on this */
static move_player_to_start(where) { 
  object ob;
  object temp;
  int treas_c, i, player_db_id;
  status exec_flag;
  string junk,junkb,tmp_name;
  
  tmp_name = name;
  name = exec_flag = 0;
  other_copy = find_player(tmp_name);
  if (!other_copy)
  	other_copy = find_player("ghost of " + tmp_name);
  name = tmp_name;
  if (other_copy && other_copy != this_object()) {
    if (interactive(other_copy)) {
      write("You are already playing!\nReconnect? ");
      call_out("timeout",60);
      input_to("try_throw_out");
    }
    else {
      write("Reconnecting to linkdead character.\n");
      log_file("ENTER", name+" (reconnect)\n");
      other_copy->rem_discon();
      /* 08/16/06 Earwax: Crude hack just to see if it cuts down on this */
      for (i = 0; i < 3; i++) {
        if(exec(other_copy, this_object())) {
          exec_flag = 1;
          break;
        }
      }
      if (!exec_flag) {
        write("Something has gone wrong....\n");
        write("Transfering items to storage box, removing other copy.\n");
        other_copy->set_saved_where(file_name(environment(other_copy)));
        other_copy->discon_quit();
        /* Crude patch to fix exec failures  -Bp */
        destruct("obj/player");
         /* Log it */
         log_file("EXEC",name+" had exec fail.\n");
         write("Disconnecting, please try again...\n");
      }
/*
#ifdef __LDMUD__
      else this_player()->reset_modify_command();
#endif
*/
      destruct(this_object());
 
      if (other_copy && environment(other_copy))
        tell_room(environment(other_copy),
          capitalize(name) + " reenters the game.\n");
    }
    return;
  }
  set_living_name(name);
  if(soul)
    destruct(soul);
  soul("on");
   
  if(level >= CREATE)
  {
    if (ok_edit && name != "earwax" && ok_edit != "none#")
    {
      write_file("/log/OKEDIT", ctime()+": "+name+" ... "+ok_edit+"\n");
/*
      ok_edit = 0;
*/
    }
    cat ("/MANAGEMENT");
    write(read_bytes("/WIZNEWS", 0, file_size("/WIZNEWS")));
  }
  else {
    if(where == "room/adv_guild") cat("/doc/short_news");
    if(where != "room/adv_guild")
      cat ("/MANAGEMENT");
      write(read_bytes("/NEWS", 0, file_size("/NEWS")));
  }
/*
#ifdef __LDMUD__
  cat("/LD_NEWS");
db_get_rs("update players set level=" + level + ", xlevel=" + ex_lv+ " where name='" + name +"'");
player_db_id = (int)"/object/mysql/player"->get_player_info(name,"id");
db_get_rs("update passwd set passwd='" + password + "' where fk_player_id = " + player_db_id);
#endif
*/
  if(name=="guest") {
    write("\nNote: guest will automatically quit after 200 seconds\n");
    log_file("GUEST", ctime()[4..15]+" "+ctime()[20..23]+" "+
     query_ip_number(this_object())+"  "+
     query_ip_name(this_object())+"\n");
  }
  if (new_pl_rest != 1) 
    restore_object("pfiles/" + extract(name,0,0) + "/" + name);
  else save_me();
    no_give = 0;
  if (weapon_class > WEAPON_CLASS_OF_HANDS)
    weapon_class = WEAPON_CLASS_OF_HANDS;

  EnableWizAnsiPrefs();
  EnableSeniorAnsiPrefs();
  this_object()->add_ansi_pref("equip", 0);
  this_object()->restore_aliaii();
  this_object()->restore_nicknames();
  if (crime)
    call_out("clear_crime", 1500);
  if (armor_class > 0)
    armor_class = 0;
  if (query_invis() < 10000)
    log_file("ENTER", ctime()[4..15] + " " + ctime()[20..23] + " (" + name +
             ") enter "+experience + " ep, " + money + " g.\n");
  new_pl_rest = 0;
  set_max_spell();
  if (!dexterity) dexterity = 8;
  if (!charisma) charisma = 8;
  if (auto_load == "")
    auto_load = 0;
  if(saved_where) {
    move_object(myself, saved_where);
    load_auto_obj(auto_load);
    saved_where = 0;
  } else {
    if (where) {
      move_object(myself, where);
      load_auto_obj(auto_load);
    } else {
      if (home) {
        load_auto_obj(auto_load);
        if (!catch(home->blahhh(0))) {
	  move_object(myself, home);
        }
        else
          move_object(myself, "/room/vill_green");
      } 
      else {
        move_object(myself, "room/vill_green");
	load_auto_obj(auto_load);
      }
    }
  }
  checked_say(cap_name + " enters the game.\n");
  if(where=="room/adv_guild") {
    cat("/doc/helpdir/newbie_attribs");
    write(HIY + "\n\nNew players: If you are lost, type 'recall'.\n\n" + NORM);
    write(HIW + "The New Adventurer's Hall is located n,3w,enter hall from " +
          "here.\n\n" + NORM);
  }
  temp = first_inventory(this_object());
/*
  while(temp && !gob) {
    if (temp->id("GI")) gob = temp;
    temp = next_inventory(temp);
  }
*/

#ifndef __LDMUD__ /* Rumplemintz */
  gob=present("GI",this_object());
  if(gob)
  if(!gob) {
   if(guild_file)
    {
     if(!catch(call_other(guild_file,"???")))
    if(guild_file->id("GI") && !guild_file->query_auto_load())
      {
        gob=clone_object(guild_file);
        move_object(gob, this_object());
      }
    }
  }
  if(gob) gob->guild_login();
#endif

  call_out("shoutin",0);
  if (query_invis())
    write("YOU ARE INVISIBLE = " + query_invis() + "!\n\n");
  if (muffled)
    write("YOU HAVE ON EAR MUFFS.\n");
  if (ghost)
    write("YOU ARE A GHOST!\n\n");
  call_other("room/post", "query_mail");
  if (called_from_ip && query_ip_number() != called_from_ip)
    if(name != "guest")
      write("Your last login was from " + called_from_ip + "\n");
  called_from_ip = query_ip_number();
  sethost();
  if (lastime) {
    write("Your last login was on " + lastime + "\n");
  }
  old_last=lastime;
  lastime = ctime()[4..15] + ctime()[19..24];
  if(!race && gender !="creature") race = "human";
  if(!race && gender =="creature") race = "creature";
  if(race !="creature" && gender =="creature") {
    race = "creature"; gender=="male"; 
  }
  if(gender =="creature") gender="male";

#if 0 /* I really hate chasing down code....  - Rumplemintz */
#include "/obj/player/dr/closed_guild_check.c"
#else
  if (this_object()->query_guild_name()) {
    if (sscanf(this_object()->query_guild_name(), "warrio%s", junk)
        || sscanf(this_object()->query_guild_name(), "symbiot%s", junk)
        || sscanf(this_object()->query_guild_name(), "Knights Temp%s", junk)
        || sscanf(this_object()->query_guild_name(), "neo symb%s", junk)) {
      if (auto_load &&
          sscanf(auto_load, "%smaledicta/closed/w/gob%s", junk, junkb) == 2) {
        write(
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"+
"**************************************************************************\n"+
"maledicta's warriors are now closed\n"+
"clearing guild status and swapped exp.....\n");
        log_file("MAL_GUILD", cap_name + " " + guild_name + " " + guild_exp +
                 " " + this_object()->query_guild_exp() * 2/3 + "\n");
        player_killing = 0;
        this_object()->set_guild_name(0);
        write(guild_name);
        experience += guild_exp*2/3;
        write(experience + " " + guild_exp);
        this_object()->add_guild_exp(-this_object()->query_guild_exp());
        this_object()->add_guild_rank(-this_object()->query_guild_rank());
        destruct(present("warrior_gob", this_object()));
        write("All set.\n");
        write(
"**************************************************************************\n"+
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
      }
      if (auto_load && sscanf(auto_load, "%smaledicta/venom%s", junk, junkb)
          == 2) {
        write(
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"+
"**************************************************************************\n"+
"maledicta's symbiotes are now closed.\n"+
"clearing guild status and swapped exp.....\n");
        log_file("MAL_GUILD", cap_name + " " + guild_name + " " + guild_exp +
                 " " + this_object()->query_exp()/3+"\n");
        player_killing = 0;
        this_object()->set_guild_name(0);
        this_object()->add_exp(this_object()->query_exp()/3);
        this_object()->add_guild_exp(-this_object()->query_guild_exp());
        this_object()->add_guild_rank(-this_object()->query_guild_rank());
        destruct(present("venom_object", this_object()));
        write("All set.\n");
        write(
"**************************************************************************\n"+
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
      }
    }
  }
#endif /* 0 */

  setup_atrbr();
  if (treasure > 0) {
    if (treasure_str[1]) {
      write("Restoring lost inventory items...\n");
      treas_c = 0;
      while (treas_c<NUMOBS_STOR) {
        object t_ob;
        string err,arg;
        int hit,miss;
        if (treasure_str[treas_c]) {
          sscanf (treasure_str[treas_c],
                  "%s#%s$%d@%d",
                  treasure_str[treas_c], arg, hit, miss);
          if (err = catch(t_ob = clone_object(treasure_str[treas_c])) )
            t_ob = clone_object("/players/boltar/things/hcookie");
          if (arg) t_ob->locker_init(arg);
          if (hit) t_ob->set_hits(hit);
          if (miss) t_ob->set_misses(miss);
          move_object(t_ob,this_object());
        } 
        treasure_str[treas_c]=0;
        hit = 0; miss = 0; arg = 0;
        treas_c+=1;
      }
      recalc_carry();
    }
    write("Restoring value from lost inventory items...\n");
    if(treasure == 314159265) treasure = 1; /*safety*/
    if (treasure > 1000)
      log_file("earwax.reimburse", ctime()+": "+name+" " + treasure+"\n");
    if (treasure > 200000) treasure = 200000;
    money += treasure;
    if(money > 80000) money = 80000;
    treasure = 0;
  }
  qc = 0;
  /* set quit counter to zero */

#ifdef __LDMUD__ /* Rumplemintz - Moving guild stuff to here for testing */
  gob = present("GI", this_object());
/*  if (gob) - WTF? */
    if (!gob) {
      if (guild_file) {
        if (!catch(call_other(guild_file, "???")))
          if (guild_file->id("GI") && !guild_file->query_auto_load()) {
            gob = clone_object(guild_file);
            move_object(gob, this_object());
          }
      } 
    }
  if (gob) gob->guild_login();
#endif

  ob = first_inventory(environment());
  while (ob) {
    if (ob != this_object()) {
      string sh;
      sh = call_other(ob, "short");
      if (sh)
        write(sh + ".\n");
    }
    ob = next_inventory(ob);
  }
  if ((int)this_object()->query_level() >= WIZARD)
    if (file_size("/players/" +
        this_object()->query_real_name() + "/login") > 0)
      RUN_COMMAND_FILE->wiz_auto_exec();
  if (this_object()->query_level() <= APPRENTICE)
    save_me();
}

/*
#ifdef __LDMUD__
void reset_modify_command()
{
  set_modify_command(this_object());
}
#endif
*/

add_hit_point(arg) {
  object thypl;
  int TGR; 
  int INF_MIN, INF_MAX, INF_ADD;
  int liv_infuse,LIV_INFUSE_LIMIT;
  thypl = this_player();
  if(thypl)
    if (level < EXPLORE && thypl->query_interactive() && thypl != this_object()){
      if(thypl->query_level() > EXPLORE)
        log_file("POINTS", name +" hp-add "+ arg + thypl->query_real_name() +" "+ ctime() +"\n");
      else 
        if(environment(thypl) != environment(this_object())) {
          arg = 0;
          /* tell_object(thypl,"Player to Player Hit Point transfers are not allowed.\n"); */
          tell_object(thypl,cap_name+" is not here.\n");
          tell_object(this_object(),"Attempted Hit Point transfer Aborted.\n");
        return 1; }
        if(thypl->query_guild_name() == "healer") { 
           TGR = thypl->query_guild_rank();   /* between 5 and 40 */ 
           INF_MIN = liv_infuse + (3 - TGR/10)*arg/2; 
           INF_MAX = LIV_INFUSE_LIMIT/2 + TGR; 
           INF_ADD = ((6 - (TGR / 7)) * arg / 2);
           if(INF_MIN < 0) INF_MIN = 0; 
           if(INF_MAX < 0) INF_MAX = 0;
           if(INF_ADD < 0) INF_ADD = 0; 
        } else { INF_MIN = infuse+3*arg/2; INF_MAX = (INFUSE_LIMIT)/2; INF_ADD = 3*arg/2; }
        if(((INFUSE_LIMIT) < INF_MIN ||infuse >INF_MAX) && arg > 0) {
          int blah;
          blah = 2*((INFUSE_LIMIT) - infuse)/3;
          tell_object(thypl,cap_name+" must wait before absorbing "+arg+" hit points.\n");
          if(infuse < INF_MAX && blah > 0 && arg > 0)
            tell_object(thypl,cap_name+" may absorb up to "+blah+" hit points.\n");
          tell_object(this_object(),"You must wait before absorbing more hit points.\n");
          arg = 0;
        return 1; }
        if(arg > 0) infuse += INF_ADD;
    }
    if(!this_object()->query_interactive()) {
       say(cap_name+" is disconnected.\n");
       stop_fight(); if (this_player()) this_player()->stop_fight();
    return 0; }
    if(arg < 0)
    {
      object x;
      dam_taken_this_round += (-arg);
      if(x=present("damage_report_object", this_object()))
        x->report_damage(-arg, previous_object());
    }
    hit_point += arg;
    if (hit_point > max_hp) hit_point = max_hp;
    if (hit_point < 0) hit_point = 0;
}

add_spell_point(arg) {
  object thypl;
  int TGR;
  int INF_MIN, INF_MAX, INF_ADD;
  int liv_infuse,LIV_INFUSE_LIMIT;
  thypl = this_player();
  if(thypl) 
    if (level < EXPLORE && thypl->query_interactive() && thypl != this_object()) {
      if(thypl->query_level() > EXPLORE) 
        log_file("POINTS", name +" sp-add "+ arg + thypl->query_real_name() +" "+ ctime() +"\n");
      else {
        if(environment(thypl) != environment(this_object())) {
          arg = 0;
          tell_object(thypl,cap_name+" is not here.\n");
          tell_object(this_object(),"Attempted Spell Point transfer Aborted.\n");
        return 1; }
        if(thypl->query_guild_name() == "healer") { 
           TGR = thypl->query_guild_rank();
           INF_ADD = ((6 - (TGR / 7)) * arg / 2);
           if(INF_MIN < 0) INF_MIN = 0; 
           if(INF_MAX < 0) INF_MAX = 0;
           if(INF_ADD < 0) INF_ADD = 0;
        } else { INF_MIN = infuse+3*arg/2; INF_MAX = (INFUSE_LIMIT)/2; INF_ADD = 3*arg/2; }
        if(((INFUSE_LIMIT) < INF_MIN ||infuse >INF_MAX) && arg > 0) {
          int blah;
          blah = 2*((INFUSE_LIMIT) - infuse)/3;
          tell_object(thypl,cap_name+" must wait before absorbing "+arg+" spell points.\n");
          if(infuse < INF_MAX && blah > 0 && arg > 0)
             tell_object(thypl,cap_name+" may absorb up to "+blah+" spell points.\n");
          tell_object(this_object(),"You must wait before absorbing more spell points.\n");
          arg = 0;
        return 1; }
        if(arg > 0) infuse += INF_ADD;
      }
    }
    spell_points += arg;
    if(arg < 0 && guild_name=="Knights Templar" && this_object()->query_mounted()) spell_points += 2*arg/3;
    if (spell_points > max_spell) spell_points = max_spell;
}

/* needs to stay */
drop_one_item(ob) {
    int weight;

    if (call_other(ob, "id", "soul") || (call_other(ob, "drop", 0) && !power))
        return 0;
    if (!ob)
        return 0;
    weight = call_other(ob, "query_weight");
    if (!weight)
	weight = 0;
    add_weight(-weight);
    move_object(ob, environment(myself));
    return 1;
}

/* needs to stay */
drop_all(verbose) {
    object ob;
    object next_ob;
    if (!myself || !living(myself))
        return;
    ob = first_inventory(myself);
    while(ob) {

	string out;
	next_ob = next_inventory(ob);
	it = call_other(ob, "short");
	if (drop_one_item(ob) && verbose) {
	    out = it + ".\n";
	    checked_say(cap_name + " drops " + out);
	    tell_object(myself, "drop: " + out);
	}
	ob = next_ob;
    }
}

valid_name(str) {
  int i, length;
  if (str == "logon") {
    write("Invalid name.\n");
	  return 0;
  }
  length = strlen(str);
  if (length > 11) {
	  write("Too long name.\n");
	  return 0;
  }
  i=0;
  while(i<length) {
	  if (str[i] < 'a' || str[i] > 'z') {
	    write("Invalid characters in name:" + str + "\n");
	    write("Character number was " + i + ".\n");
      /* log_file("BAD_NAME", str + "\n"); */
	    return 0;
    }
	  i ++;
  }
  return 1;
}

change_password(str) {
    if (password && password !="" && !str) {
	write("Give old password as an argument.\n");
	return 1;
    }
    if(password)
    if (crypt(str, extract(password,0,1)) != password) {
	write("Wrong old password.\n");
	return 1;
    }
    write("New password: ");
    password2 = 0;
    input_to("change_password2", 1);
    return 1;
}

static change_password2(str) {
int player_db_id;
    if (!str) {
	write("Password not changed.\n");
	return;
    }
   if(strlen(str) < 6) {
     write("Password must be at least 6 characters long.\n");
     return;
   }
    if (password2 == 0) {
	password2 = str;
	write("Again: ");
	input_to("change_password2", 1);
	return;
    }
    if (password2 != str) {
	write("Wrong! Password not changed.\n");
	return;
    }
    password = crypt(password2,0);
    password2 = 0;
    write("Password changed.\n");
/*
#ifdef __LDMUD__
player_db_id = (int)"/object/mysql/player"->get_player_info(name,"id");
db_get_rs("update passwd set passwd='" + password + "' where fk_player_id = " + player_db_id);
#endif
*/
    if (level < EXPLORE ) {
    write("Please enter a password reminder hint.\n");
    write("Please note anyone may view it.\nHint: ");
    input_to("gethint");
    }
}

void set_whimpy(int w){
  whimpy=w;
}

mixed query_whimpy(){
  return whimpy;
}

void set_whimpy_dir(string str){
  whimpy_dir=str;
}

string query_whimpy_dir(){
  return whimpy_dir;
}

int query_brief() { return brief; }
#ifndef __LDMUD__ /* Rumplemintz */
int toggle_brief(int arg) { brief = arg; }
#else
void toggle_brief(int arg) { brief = arg; }
#endif

add_exp(x) {
  string tmpo,tmpi;
  int e;
  e = (x * 1);
  if (this_player() && previous_object() && this_player() != this_object() && this_player()->query_level() > 1 && query_ip_number(this_player()) && level < 20 ) {
    sscanf(file_name(previous_object()),"%s#%s",tmpo,tmpi);
    if(tmpo != "obj/party" && file_name(previous_object()) != "obj/partymaster") {
      log_file("EXPERIENCE", ctime() +" "+ name +"("+ level +
      ") " + e + " exp by " + this_player()->query_real_name() + 
      "(" + this_player()->query_level() + ")" +"\n");
      log_file("EXPERIENCE",file_name(previous_object())+"-^\n");
    }
  }
  if (is_interactive) {
    exp_login += (e);
    call_other("obj/exp_store.c","collector",cap_name,e);
    if(e > 0 && experience + e < 0) {
      experience = 2147483647;
    } else {
      experience += (e);
    }
  }
  if (level <= 19)
    add_worth(e);
}

second_life() {
  int lt;
  string st;
  object here;
  if (level >= EXPLORE)
	  return illegal_patch("second_life set_level");
  ghost = 1;
  msgin = "drifts around";
  msgout = "blows";
  headache = 0;
  intoxicated = 0;
  hunter = 0;
  hunted = 0;
  attacker_ob = 0;
  alt_attacker_ob = 0;
  save_me();
  tell_object(myself,"\n\n");
  st="You die.";
  lt=strlen(st); lt=40-(lt/2);
  tell_object(myself, pad(" ",lt-1)+st+"\n");
  st="You have a strange feeling.";
  lt=strlen(st); lt=40-(lt/2);
  tell_object(myself, pad(" ",lt-1)+st+"\n");
  st="You can see your own dead body from above.";
  lt=strlen(st); lt=40-(lt/2);
  tell_object(myself, pad(" ",lt-1)+st+"\n");
  st="setting hit points to 1/3 max....";
  lt=strlen(st); lt=40-(lt/2);
  tell_object(myself, pad(" ",lt-1)+st+"\n");
  tell_object(myself, "\n\n");
  clear_followers();
  clear_follow();
  here=environment(this_object());
  
  if(here->pk_tourney())
    return 1; 
 
  move_object(clone_object("/obj/tunnel"),here);
  tell_room(here,"A white dot appears and expands into a bright white "+
    "tunnel.\n");
  tell_room(here,"The tunnel shimmers slightly as it grows in strength.\n");
  tell_object(myself, "You feel a desire to enter the tunnel.\n");
  return 1;
}

int remove_ghost_confirm(string str)
{
   if(!str || (str != "y" && str != "Y" && str != "yes" && str != "Yes"))
     return 0;
  this_object()->remove_ghost_finish();
   return 1;
}

int remove_ghost()
{
  if(this_player()==this_object()) {
   write("You are being revived. Continue (y or n) ? : ");
   input_to("remove_ghost_confirm");
  } else {
   prompt_revive=1;
  }
   return 1;
}

remove_ghost_finish() {
   object thing;
   int cexp;
    if (!ghost)

	return 0;
    if(PKGhostCounter) return (tell_object(this_object(), "\nYou may not be revived from death for another " + PKGhostCounter + " seconds.\n\n"), 1);
    tell_object(this_object(), "You feel a very strong force.\n");
    tell_object(this_object(), "You are sucked away...\n");
    tell_object(this_object(), "You reappear in a more solid form.\n");
    if(environment()) {
    tell_room(environment(), "Some mist disappears.\n", ({ this_object() }));
    tell_room(environment(), cap_name + " appears in a solid form.\n", ({ this_object() }));
    }
    ghost = 0;
    dead = 0;
    msgin = "arrives";
    msgout = "leaves";
   if(present("guild_death_object", this_object())){
   thing = present("guild_death_object",this_object());
  call_other(thing, "guild_death",0);
   }
   else {
     cexp=call_other("room/adv_guild", "check_level", level);
     if(experience < cexp)
       call_other("room/adv_guild", "correct_level", this_player());
     if (ex_lv) {
      cexp=call_other("room/exlv_guild", "check_level", ex_lv);
      if(experience < cexp)
        call_other("room/exlv_guild", "correct_extra_level", this_object());
     }
   }
    save_me();
    return 1;
}

object query_hunted(){
  return hunted;
}

void set_hunted(object x){
  hunted=x;
}

set_invs_sp() {
   is_invis=(level > 20 ? 19 : 18);
   invs_flag = 1;
   invs_count = 0;
   return 1;
}
unset_invs_sp() { is_invis = invs_flag = invs_count = 0; return 1; }

invs_counter () {
  if (invs_flag != 0) {
    invs_count ++;
    if (invs_count > 14+random(8)) {
      write ("You are visible again.\n");
      is_invis=0;
      invs_count=0;
      invs_flag = 0;
    }
  }
  return 1;
}

status query_no_give(){
  return no_give;
}

/* 05/16/06 Earwax:  daemonized pose */

save_me(arg) {
    string ab,bc;
  if(!this_object()) return;
    sscanf(file_name(this_object()), "%s#%s",ab,bc);
/* Added in check for /obj/player as well - Rumplemintz */
    if(ab != "obj/player" && ab != "/obj/player")
     {
        this_object()->illegal_patch("cloned player.c add_commands block");
	destruct(this_object());
	return;
    }
    if(!inact && arg !=3)
    if(!environment(this_object())) return 0;
    if(!inact && arg !=3)
    compute_auto_str();
    if (level < EXPLORE)
	compute_treasure();
     if(level < 2) ok_edit="new_bie567";
     if(level > 2 && ok_edit=="new_bie567") ok_edit = 0;
    if (level)
	save_object("pfiles/" + extract(name,0,0) + "/" + name);
    if(this_player() == this_object() && !inact && arg !=3)
    if (level > EXPLORE || file_size("/players/"+name+".o") > 0)
        save_object("players/"+name);
}

illegal_patch(what) {
    write("You are struck by a mental bolt from the interior of the game.\n");
    log_file("ILLEGAL",
	     capitalize(call_other(this_player(), "query_real_name")) + " " +
             ctime() +" "+ what +"\n");
    return 0;
}

load_auto_obj(str) {
  string file, argument, rest;
  object ob;

  while (str && str != "") {
  	if (sscanf(str, "%s:%s^!%s", file, argument, rest) != 3) {
	    write("Auto load string corrupt.\n");
	    return;
	  }
	  str = rest;
	  ob = find_object(file);
	  if (!ob)
      continue;
	  ob = clone_object(file);
	  if (argument)
	    call_other(ob, "init_arg", argument);
    if(ob)
	    move_object(ob, this_object());
  }
"/bin/play/_update_clan"->cmd_update_clan();
}

compute_auto_str() {
  object next_ob,ob;
  string str;

  auto_load = "";
  ob = first_inventory(this_object());
  while (ob) {
	  str = call_other(ob, "query_auto_load");
	  next_ob = next_inventory(ob);
	  ob = next_ob;
	  if (!str)
	    continue;
	  auto_load = auto_load + str + "^!";
  }
}

/* query_gear
 * returns all items worn/wielded by a player
 * 07/13/06 Earwax
 */
object *query_gear() {
  int i, count;
  object *allinv, *gear, ob;
  
  count = 0;
  i = sizeof(allinv = all_inventory(this_object()));
  gear = allocate(i);
  
  while(i--) {
    ob = allinv[i];
    if ((int)ob->query_save_flag() == 1 || ob->query_auto_load()
    || ob->id("GI") || ob->is_container())
      continue;
      
    if (ob->query_worn() || ob->query_wielded() || ob->query_offwielded()) {
      gear[count] = ob;
      count++;
    }
  }
  
  if (count) count--;
  
  return (count > -1 ? gear[0..count] : ({ }));
}
  
compute_treasure() {
    object ob;
    int x, s;
    object *obs;
    int v,b,c;
    string str,a;

    if(name=="numberthree") write("COMPUTE!\n");
    if(treasure == 314159265){ 
      treasure = 1; 
      return 1;
    } /* flagging above prevents clearing reboot cross save */
    
    treasure = c = 0;
    
    while(c<NUMOBS_STOR) {
      treasure_str[c]=0;
      c++;
    }
    
    c=0;
    obs = deep_inventory(this_object());
    s=sizeof(obs);
    b=0;    
    for(x=0;x<s;x++) {
       ob = obs[x];
       if(!ob) continue;
       if(ob->short())
         if(!ob->query_save_flag() && !ob->query_auto_load() &&
            !ob->id("GI") && ((ob->generic_object() && 
            ob->locker_arg()) || !ob->generic_object()) ){
           str = file_name(ob);
           if(sscanf(str, "players/%s#%d",a,c)==2) {
             sscanf(str,"%s#%d",a,c);
             str = a;
             str = str + "#" + ob->locker_arg();
             str = str + "$" + ob->query_hits();          
             str = str + "@" + ob->query_misses();
             if(b<NUMOBS_STOR)
               treasure_str[b] = str;
             b += 1;
           }
         } 
      if(!c || b > NUMOBS_STOR-1) {
        v += call_other(ob, "query_value");
        if(name=="numberthree") write("COMPUTE! "+v+"\n");
/*
	if (v <= 100000) treasure += v;
	else treasure += 1000;
*/
        if(v >= 1500) v = 1000+random(500);
        treasure += v;
      } else treasure += 1;
        v = 0;
        c = 0;
    }
    return treasure;
}



int query_inacttwo() { return inacttwo; }

#if 0 /* Tired of searching for this... Rumplemintz */
#include "/obj/player/dr/read_write.c"
#else
nomask mixed valid_write(string arg, object c) {
  string str, who, tmpa, tmpb, tmpc, file, temp;
  string tpa, tpb, fname;
  int tempb;
  object prev_caller;
  string bbbttttj;
  string heh, heh2;
  mixed result;

  /* Allow wizards to change the central wlog, if wlog calls it */
  if (level >= CREATE &&
      arg == "/log/WR/WORK_REPORT" &&
      previous_object() && file_name(previous_object()) == "bin/wiz/_wlog") {
    return ("log/WR/WORK_REPORT");
  }

/* ghetto fix. don't know why this makes things happy -Bp */
/*
  if(level > CREATE)
  bbbttttj = creator(caller());
*/

  if (!arg) return 0;
#if 1 /* Rumplemintz */
  prev_caller = caller();
#else
  prev_caller = previous_object();
#endif
/*
  fname = (c ? file_name(c) : 0);
*/
#if 1 /* Rumplemintz */
  if (caller() != myself || !c)
    c = caller();
#else
  if (previous_object() != myself || !c)
    c = previous_object();
#endif
/* If the caller is not this_object, then get the file_name of the caller,
   and if it comes from one of these directories, allow it */
  if (c != this_object() && !in_editor(this_object()))

/*
  if (fname &&
   (  fname[0..3] == "room"
  ||  fname[0..2] == "obj"
  ||  fname[0..2] == "bin"
  ||  fname[0..2] == "sys"
  ||  fname[0..5] == "secure"
  ||  fname[0..6] == "daemons"
  ||  fname[0..5] == "closed"))
    c = this_object();
*/
  if (extract(file_name(c),0,3)=="room" ||
      extract(file_name(c),0,2)=="obj" ||
      extract(file_name(c),0,2)=="bin" ||
      extract(file_name(c),0,5)=="secure" ||
      extract(file_name(c),0,2)=="lib" ||
      extract(file_name(c),0,2)=="sys" ||
      extract(file_name(c),0,6)=="daemons" ||
      extract(file_name(c),0,5)=="kernel" ||
      extract(file_name(c),0,5)=="global" ||
      extract(file_name(c),0,4)=="basic" ||
      extract(file_name(c),0,6)=="complex" ||
      extract(file_name(c),0,5)=="closed")
    c=this_object();

  if (in_editor(this_object()))
    c = this_object();

  if(inact && !inacttwo) {
    if((int)get_handshake(handshake) != inact)
      return 0;
    if (sscanf(arg, "/pfiles/%s.o", who) == 1) {
      if(who == extract(name,0,0)+"/"+name)
#ifndef __LDMUD__
        return "pfiles/"+extract(name,0,0)+"/"+name+".o";
#else
        return "/pfiles/" + name[0..0] + "/" + name + ".o";
#endif
      return 0;
    }
    write("past-pfile-name-check");
    if (sscanf(arg, "/players/%s.o", who) == 1) {
      if(who == name)
        return "players/"+name+".o";
      if (sscanf(arg, "/players/inactive_saved/%s.o", who) == 1) {
        if(who == name)
          return "players/inactive_saved/" + name + ".o";
        return 0;
      }
      return 0;
    }
    if (sscanf(arg, "/players/inactive_saved/%s.o", who) == 1) {
      if(who == name)
        return "players/inactive_saved/" + name + ".o";
      return 0;
    }
    return 0;
  }
  if (sscanf(arg, "/bin/soul/%s", who) &&
      prev_caller &&
      basename(prev_caller) == "/bin/soul/editor")
    return "bin/soul/"+who;
  if (sscanf(arg, "/doc/helpdir/%s", who))
    return "doc/helpdir/"+who;
  if(sscanf(arg, "/pfiles/notes/%s", who))
    return "pfiles/notes/"+who;
#ifndef __LDMUD__
  if (extract(arg,0,8)=="/Driver32") {
#else
  if (arg[0..8] == "/Driver32") {
#endif
    if(sscanf(arg, "%splayers%s", tmpa, tmpb) !=2 )
      return 0;
    else {
      tmpa = 0;
      sscanf(tmpb, "/%s/", tmpa);
      if(!tmpa)
        sscanf(tmpb, "/%s", tmpa);
      if(tmpa == name)
#ifndef __LDMUD__
        return extract(arg,1,strlen(arg));
#else
        return arg[1..strlen(arg)];
#endif
      return 0;
    }
  }
  str = arg;
  if (str == "~" || str == "~/")
    str = "/players/" + name;
  else if (sscanf(str, "~/%s", temp) == 1)
    str = "/players/" + name + "/" + temp;
  else if (sscanf(str, "~%s", temp) == 1)
    str = "/players/" + temp;
  else if (str[0] != '/')
    str = pwd + str;
  if(sscanf(str, "/doc/helpdir/%s",who) &&
     name == "star")
    return "doc/helpdir/"+who;
/* Disallow any of these combinations */
  if (sscanf(str, "%s//%s", temp)) return 0;
  if (sscanf(str, "//%s", temp)) return 0;
  if (sscanf(str, "/.%s", temp)) return 0;
  if (sscanf(str, "%s/.%s", temp, temp)) return 0;

  if (sscanf(str, "/players/%s/%s", who, file) == 2) {
    if(c == this_object() && sscanf(str, "/players/guilds/%s",tmpa) == 1) {
      if("/players/guilds/access"->valid_write(name,str))
        return "players/guilds/" + tmpa;
    }  
    if(level < ELDER && level > 20)
      if(sscanf(str,"%s" + name + "%s",tpa, tpb) != 2)
        if(sscanf(file_name(c), "players/" + who + "/%s", temp) != 1) {
          string a, b;
          string vvverb;
          vvverb = query_verb();
          if(vvverb == "mv" || vvverb == "cp" || vvverb == "ed" ||vvverb=="rm")
            if(level < 1000)
              log_file("ED_OTHER", name + " [" + vvverb + "] " + str + " " +
                       ctime(time()) + "\n");
        }
    if(!ok_edit)
      ok_edit = "none#";
    if ((who == ok_edit ||
         sscanf(ok_edit, "%s" + who + "%s", tmpa, tmpb) == 2 ||
         who == name ||
         level >= ED_OTHERS) &&
        c == this_object()) {
      if (sscanf(ok_edit, "%s" + who + "/%s#%s", tmpa, tmpb, tmpc) == 3) {
        if(sscanf(str, "%s" + tmpb + "%s", tmpa, tmpc) == 2)
          return "players/" + who + "/" + file;
        else
          return 0;
      }
      if (who != "tar_castles" ||
          who != "inactive_saved" ||
          who != "pre_reno" ||
          level >= ELDER)
        return "players/" + who + "/" + file;
    }
    if (sscanf(file_name(c), "players/" + who + "/%s", temp)==1)
      return "players/" + who + "/" + file;
    return 0;
  }
  if (sscanf(str, "/players/%s.o", file) == 1)
    if(level >= ELDER ||
       (prev_caller && file_name(prev_caller) == "obj/simul_efun"))
      return "players/" + file + ".o";
  if (sscanf(str,"/open/%s", file) == 1) {
    string vverb;
    vverb = query_verb();
    if(vverb == "mv" || vverb == "cp" || vverb == "ed" || vverb == "rm")
      log_file("ED_OTHER",name+" ["+vverb+"] "+str+" "+ctime(time())+"\n");
    return "open/" + file;
  }
  if (sscanf(str, "/log/WR/%s_%s", who,file) == 2)
    if (who == name || level >= ED_LOG)
      return "log/WR/" + who + "_" + file;
  if(sscanf(str, "/log/user/%s", who) &&
      ((prev_caller && basename(prev_caller)[0..8] == "/obj/user") ||
      (level >= ED_LOG)))
    return "log/user/"+who;
  if(sscanf(str, "/doc/%s",file) && level >= ELDER) return "doc/"+file;
  if(sscanf(str, "/pa/log/%s", who) == 1) {
        if((prev_caller && (basename(prev_caller)=="/obj/soul" || basename(prev_caller)=="/closed/wiz_soul")) || level >= SENIOR)
    {
    return "pa/log/"+who;
    }
  }
  if(sscanf(str, "/pa/admin/%s", who) == 1) {
    if(level < SENIOR) return 0;
  }
  if(sscanf(str, "/pa/%s", who) == 1) {
    if(who=="log/Snoop.txt")
      if(query_verb()=="snoop") return "pa/"+who;
    else if(level >= SENIOR || "/pa/admin/pa-daemon"->query_name(name))
   {
      return "pa/"+who;
  }
  }
  if (sscanf(str, "/log/SQLDATA/%s.%s", who,file) == 2)
    if (who == name || level >= ED_LOG)
      return "log/SQLDATA/" + who + "." + file;
  if(sscanf(str, "/ideas/sugg_old/%s", file) == 1)
    return "ideas/sugg_old/" + file;
  if(sscanf(str, "/ideas/%s", file) == 1)
    return "ideas/" + file;
  if (c!=this_object())
    return 0;
  if (sscanf(str, "/log/%s.%s", who,file) == 2)
    if (who == name || (capitalize(who) != who &&
        level >= ED_OTHERS) || level >= ED_LOG)
      return "log/" + who + "." + file;

  if (sscanf(str, "/log/%s", who) == 1) {
    if (who == name ||  (capitalize(who) != who &&
        level >= ED_OTHERS) || level >= ED_LOG)
      return "log/" + who;
#if 0
#ifndef __LDMUD__
#endif
    if(who == ok_edit || sscanf(ok_edit, "%s"+who+"#%s", tmpa,tmpb)==2 ||
       sscanf(ok_edit, who+"%s", tmpa))
     return "log/" + who;
#if 0
#endif
#endif
  }

  if ((sscanf(str, "/obj/%s", file) == 1) && level >= EDIT_STANDARD)
    return "obj/" + file;
  if((sscanf(str, "/room/housing/%s",file) == 1) && prev_caller &&
      (file_name(prev_caller)[0..11]=="room/housing"))
    return "room/housing/"+file;
  if ((sscanf(str, "/room/%s", file) == 1) && level >= EDIT_STANDARD)
    return "room/" + file;
    if ((sscanf(str, "/post_dir/%s", file) == 1) && level >= ELDER)
        return "post_dir/" + file;
    if ((sscanf(str, "/closed/%s", file) == 1) && level >= ELDER)
        return "closed/" + file;
    if ((sscanf(str, "/daemons/%s", file) == 1) && level >= ELDER)
      return "daemons/"+file;
    /* Added next 4 if's - Rumplemintz - 08/12/2011 */
    if ((sscanf(str, "/kernel/%s", file) == 1) && level >= ELDER)
      return "kernel/"+file;
    if ((sscanf(str, "/global/%s", file) == 1) && level >= ELDER)
      return "global/"+file;
    if ((sscanf(str, "/basic/%s", file) == 1) && level >= ELDER)
      return "basic/"+file;
    if ((sscanf(str, "/complex/%s", file) == 1) && level >= ELDER)
      return "complex/"+file;
    if ((sscanf(str, "/banish/%s", file) == 1) && level >= ELDER)
       return "banish/" + file;
    if ((sscanf(str, "/secure/%s", file) == 1) && level >= ELDER)
      return "secure/" + file;
    if ((sscanf(str, "/sys/%s", file) == 1) && level >= ELDER)
      return "sys/"+file;
    if ((sscanf(str, "/bin/%s", file) == 1) && level >= ELDER)
        return "bin/" + file;
    if(sscanf(str,"/pfiles/%s",file))
      if(level >= ELDER || (prev_caller &&
         file_name(prev_caller) == "obj/simul_efun"))
         return "pfiles/" + file;
    if ((sscanf(str, "/%s", file) == 1) && level >= ELDER)
      if (file && (sscanf(file, "%s/%s", str, str)!=2) && level >= ELDER)
        return file;
    if (level >= ALL_POWER) {
        sscanf(str,"/%s",file);
        return file;
    }

    
    return 0;
}

nomask string
valid_read(string arg) {
  string str, who,tmpa,tmpb, file, temp,tmp;
  object c, prev_caller;
  int tempb;

  /*
   * Because argument lists are passed unevaluated, by the time caller()
   * gets executed, the real caller() will be valid_read, not whoever
   * actually called us.  Thus, we get caller() before calling valid_write.
   */
#if 1 /* Rumplemintz */
  c = caller();

  prev_caller = caller(); /* Rumplemintz */
#else
  c = previous_object();
  prev_caller = previous_object();
#endif

  if (c != this_object() && !in_editor(this_object()))
    if (extract(file_name(c),0,3)=="room" ||
        extract(file_name(c),0,2)=="obj" ||
        extract(file_name(c),0,2)=="bin" ||
        extract(file_name(c),0,7)=="post_dir" ||
        extract(file_name(c),0,5)=="closed")
      c = this_object();
  if (level < ELDER)
    if (sscanf(arg, "%ssecure%s", temp, tmp) == 2) return 0;
  if (sscanf(arg, "%sacces%s", temp, tmp) == 2)
#ifdef __LDMUD__
    return arg[1..<1];
#else
    return arg[1..-1];
#endif
  file = valid_write(arg,c);
  if (file)
    return file;

  str = arg;
  if (str == "~" || str == "~/")
    str = "/players/" + name;
  else if (sscanf(str,"~/%s",temp) == 1)
    str = "/players/" + name + "/" + temp;
  else if (sscanf(str,"~%s",temp) == 1)
    str = "/players/" + temp;
  else if (str[0] != '/')
    str = pwd + str;
  if (sscanf(str, "//%s", temp)) return 0;
  if (sscanf(str, "%s//%s", temp, temp)) return 0;
  if (sscanf(str, "/.%s",  temp)) return 0;
  if (sscanf(str, "%s/.%s", temp) > 1) return 0;
  if (sscanf(str, "%star_castles%s", temp) > 1) return 0;
  if(sscanf(str, "/players/%s/PLAN", who) == 1)
    return "players/" + who + "/PLAN";
  if (sscanf(str, "/players/%s/closed/%s", who, file) == 2) {
    if (who == name || level >= 100)
    {
      return "players/"+who+"/closed/"+file;
    }
    return 0;
  }
  if (sscanf(str, "/players/inactive_saved/%s.o", who) == 1) {
    if (((who == name || level >= SENIOR) && c==this_object()) ||
        (prev_caller && (prev_caller == find_object("/obj/simul_efun"))))
      return "players/inactive_saved/" + who + ".o";
    return 0;
  }
  if (sscanf(str, "/players/guilds/%s",who) == 1) {
    if((level >= ITEM_OVER && c==this_object()) || 
      (c==this_object() && "/players/guilds/access"->valid_read(name,str)))
      return "players/guilds/" + who;
    return 0;
  }
  if (sscanf(str, "/players/%s/%s", who, file) == 2) {
    if(!ok_edit) ok_edit="none#";
    if ((who == ok_edit ||
         sscanf(ok_edit, "%s"+who+"%s", tmpa,tmpb)==2 ||
         who == name ||
         level >= READ_OTHERS) &&
        c == this_object()) {
      return "players/" + who + "/" + file;
    }
    return 0;
  }
  if (sscanf(str, "/players/%s.o", who) == 1) {
    if (((who == name || level >= SENIOR) && c == this_object()) ||
        (prev_caller && (prev_caller == find_object("/obj/simul_efun"))))
      return "players/" + who + ".o";
    return 0;
  }
  if (sscanf(str, "/pfiles/%s.o", who) == 1) {
    if (((who == name[0..0]+"/"+name || level >= SENIOR)
          && c==this_object()) ||
        (prev_caller && (prev_caller == find_object("/obj/simul_efun"))))
      return "pfiles/" + who + ".o";
    return 0;
  }
  if (sscanf(str, "/post_dir/%s"+".o", who) == 1 ||
      sscanf(str, "post_dir/%s"+".o", who) == 1) {
    if ((who == name || level >= ELDER) && c==this_object())
      return "/post_dir"+"/" + who + ".o";
    return 0;
  }
  if (sscanf(str, "/pa/%s", file) == 1) {
    if (str == "/pa/admin/pa-list.txt") return "pa/admin/pa-list.txt";
    if (level >= SENIOR || "/pa/admin/pa-daemon"->query_name(name))
      return "pa/"+file;
    return 0;
  }
  if (sscanf(str, "/closed/%s", file) == 1) {
    if (level >= ELDER && c==this_object())
      return "/closed/"+file;
    return 0;
  }
  if (sscanf(str, "/%s", file) == 1)
    return file;

  write("Bad file name.\n");
  return 0;           /* Should not happen */
}
#endif

#if 0 /* Again, here - Rumplemintz */
#include "/obj/player/dr/soul_fun.c"
#else
soul(str) {
  string junk,junk2;
  object here,guild_object,temp;

  remove_call_out("timeout");
  remove_call_out("timeout");
  if (!str) return 0;
  if (str != "on" && str != "off") return 0;
  here = environment(this_object());
  if (str == "off" && !soul) {
    tell_object(myself, "You don't have one.\n");
  return 1;
  }
  if (here) save_me();

  temp = first_inventory(this_object());
  while(temp) {
    if (temp->id("GI")) guild_object = temp;
    temp = next_inventory(temp);
  }

#ifndef __LDMUD__ /* Rumplemintz */
  if(!present("GI")){
    if (!guild_object && guild_file && guild_file !="" && guild_file != 0)
    {
      if(!catch(call_other(guild_file, "id", "GI")))
      {
        gob=clone_object(guild_file);
        move_object(gob, this_object());
      }
    }
  }
#endif /* __LDMUD__ */

  if (soul) {
    if (here) {
    tell_object(myself, "You lose your soul!\n");
    if (str == "on")
      tell_object(myself, "Something's odd though...\n");
  }
    if(soul)
    destruct(soul);
  }
  if (str == "off") {
    return 1;
  }
  if (soul) {
    if (here)
    tell_object(myself, "You cannot bring yourself to do this.\n");
  return 1;
  }
  if (level < EXPLORE) {
    soul = clone_object("obj/soul");
  } else if (level < GOD) {
  soul = clone_object("closed/wiz_soul");
  } else {
  soul = clone_object("closed/wiz_soul");
  }
  move_object(soul, myself);
  if (here)
    tell_object(myself, "You have been ensouled.\n");
  return 1;
}

remote_ed(key) {
  string tpa,tpb,file;
#ifndef __LDMUD__ /* Rumplemintz */
  private;
#endif
  file = call_other(soul,"get_handshake",key);
  file = valid_write(file);
  if (!file) {
  write("You cannot edit that file.\n");
  return 1;
  }
  tell_object(myself,"editing: "+file +"\n");
  ed(file);
}
#endif

query_soul() { return soul; }

status query_errormsgs() { return errormsgs; }
void set_errormsgs(int x) { errormsgs = (x > 0); }

/*
#ifdef __LDMUD__
void remote_ed(string file) {
  if (object_name(previous_object()) != "bin/wiz/secure/_ed")
    write("Ed can only be used via the mudlib 'ed' command.\n");
  ed(file);
}
#endif
*/

remote_cmd(key) {
  string str;
    
  str = call_other(soul,"get_handshake",key);
  if (str)
    command(str);
}

remote_say(str, ignore) {
    if (ignore)
        say(str, ignore);
    else
        say(str);
}

set_wc(num) { weapon_class = num; }
set_ac(num) { armor_class = num;  }

void set_muffled(int arg) { muffled = arg; }
query_muffled() { return (level < 0? 1 : muffled); }

set_pwd(str) {
  if (this_player() != this_object()) return 0;
  if (!str) {
    write("Null path!\n");
    return;
  }
  if (str[0] == '/')
    pwd = str;
  else
    pwd = "/" + str;
}

void set_invis(int num)
{
  if (previous_object()== find_object("/bin/wiz/_invis.c")
  ||  previous_object() == find_object("/bin/wiz/_vis.c"))
    is_invis = num;
  cap_name = (is_invis > SOMEONE ? "Someone" : capitalize(name));
}

int query_invis() { return is_invis; }
get_path() { return query_pwd(); }

update (num) {
  if(!(soul = present("player_soul", this_object())) 
  && !(soul = present("wiz_soul", this_object())))
    return;
  else if (num == 5) {
    is_invis = call_other(soul,"query_invis");
	  cap_name = (is_invis > SOMEONE ? "Someone" : capitalize(name));
  }
  else if (num == 6) muffled = call_other(soul,"query_muffled");
  else if (num == 10) wkrm = call_other(soul, "query_alt_wkrm");
}

is_player() { return 1; }

query_quests(str) {
    string tmp, rest, rest_tmp;
    int i;

    if (str == -1) {
	write("quests: "+quests+"\n");
	return;
    }
    if (str == 0) {
	return quests;
    }
    rest = quests;
    while (rest) {
	if (str == rest)
	    return 1;
	i = sscanf(rest, "%s#%s", tmp, rest_tmp);
	if (i == 0)
	    return 0;
	if (tmp == str)
	    return 1;
	if (i == 1)
	    return 0;
	rest = rest_tmp;
    }
    return 0;
}

query_gender() { return gender; }
set_gender(g) {
  if (g == "creature" || g == "male" || g == "female")
    gender = g;
}

query_call_outs() {
  write("active call_outs\n");
  dump_call_out("timeout");
  dump_call_out("intoxicate");
}

dump_call_out(str) {
  int i;
  if ((i = find_call_out(str)) >= 0)
    write(str + ":\t" + i + "\n");
}

query_guild_rank() { return guild_rank; }
query_guild_exp() { return guild_exp; }
query_guild_file() { return guild_file; }
add_guild_rank(x) { guild_rank += x; }
add_guild_exp(x) { guild_exp += x; }
set_guild_file(str) { guild_file = str; }

#ifndef __LDMUD__ /* Rumplemintz */
void load_cmd_hook() { add_action("cmd_hook"); add_xverb(""); }
#else
void load_cmd_hook() {
  add_action("cmd_hook", "", 3);
}
#endif

int cmd_hook(string arg)
{
  string cmdpath, verb;
  
  if (name == "guest" && environment() && !creator(environment(this_object())))
  {
    move_object(this_object(), "/room/church");
    write("Guest cannot leave the backbone areas.\n");
  }
/*
#ifndef __LDMUD__
*/
  return ::cmd_hook(arg);
/*
#else
  if (sscanf(arg, "%s %s", verb, arg) != 2)
  {
    verb = arg;
    arg = 0;
  }

  if (level >= CREATE
  && (file_size(cmdpath = sprintf("/bin/secure/_%s.c", verb)) > 0
  ||  file_size(cmdpath = sprintf("/bin/wiz/secure/_%s.c", verb)) > 0
  ||  file_size(cmdpath = sprintf("/cmds/dev/mysql/_%s.c", verb)) > 0
  ||  file_size(cmdpath = sprintf("/cmds/dev/_%s.c", verb)) > 0
  ||  file_size(cmdpath = sprintf("/bin/wiz/_%s.c", verb)) > 0))
    return (int)call_other(cmdpath, sprintf("cmd_%s", verb), arg);

  if (file_size(cmdpath = sprintf("/bin/play/_%s.c", verb)) > 0
  ||  file_size(cmdpath = sprintf("/bin/soul/_%s.c", verb)) > 0)
    return (int)call_other(cmdpath, sprintf("cmd_%s", verb), arg);
    
  return 0;
#endif
*/
}

add_commands() {
  string ab,bc;
  
  sscanf(file_name(this_object()), "%s#%s",ab,bc);
  if(ab!="obj/player") {
    illegal_patch("cloned player.c add_commands block");
	  destruct(this_object());
	  return;
  }

/*
#ifdef __LDMUD__
set_modify_command(this_object());
#endif
*/
  load_cmd_hook();
  
#ifndef __LDMUD__ /* Rumplemintz */
  DR_dir_abbreviations();
  add_action("new_communicate", "say");
  add_action("pound_ready", "#");
  add_action("new_communicate"); add_xverb("\"");
  add_action("new_communicate"); add_xverb("'");
  add_action("soul"); add_verb("soul");
  add_action("cmd_do_talk"); add_xverb(">");
#else
  DR_dir_abbreviations();
  add_action("new_communicate", "say");
  add_action("pound_ready", "#");
  add_action("new_communicate", "\"", 3);
  add_action("new_communicate", "'", 3);
  add_action("soul", "soul");
  add_action("cmd_do_talk", ">", 3);
#endif

}
 
pound_ready()
{
 command("ready", this_player());
  return 1;
}

patch_ok_edit(str)
{
  if(query_ip_number(this_player()) && (int)this_player()->query_level() >= ELDER)
    ok_edit = str;
}

query_hostname()
{
	return (hostname ? hostname : query_ip_name ( this_object() ) );
}
static sethost() 
{
  if(this_object())
	  hostname = query_ip_name(this_object());
}

set_home(str) { home = str; }
query_home() { return home; }

set_fight_area() {
  fight_area=file_name(environment(this_object()));
  return 1;
}
clear_fight_area() { fight_area=0; return 1; }

check_fight_area() {
  if(fight_area && fight_area == file_name(environment(this_object())))
    return 1;
  fight_area = 0;
  return 0;
}

query_fight_area() { return fight_area; }
query_pl_k() { return player_killing; }
set_pl_k(x) { player_killing = x; }

query_interactive(){ return interactive(this_object()); }

void set_mailaddr(string addr) { mailaddr = addr; }
string query_mailaddr() { return mailaddr; }

static getmailaddr(maddr) {
  mailaddr = maddr;
  if(mailaddr == "") mailaddr = "none";
  move_player_to_start(0);
}

static gethint(phint) {
  hint = phint;
  if(pc == 987 && !environment(this_object())) move_player_to_start(0);
  return;
}

discon_quit(){
  object bbx;
  
  bbx = clone_object("obj/discon.c");
  if(environment())
    move_object(bbx, environment(this_object()));
  else move_object(bbx, find_object("/room/vill_green"));
  call_other(bbx, "set_owner", name);
  move_object(this_object(), bbx);
  if(!my_discon_box) my_discon_box = ({ bbx });
  else my_discon_box += ({ bbx });
  treasure = 0; /*They should be carrying nothing at this point -Bp */
  save_me();
  quit();
  return 1;
}
see_if_other(arg) { return 1; }
set_no_give(arg) {
  if (arg == 1) no_give = 1;
  else if (arg == 2) no_give = 0;
  return 1;
}

set_crime() {
  crime = 1;
  return 1;
}
query_crime() { return crime;}
clear_crime() { crime = 0; return 1; }

query_al_title() {return al_title;}
set_al_title(al) { al_title = al;  return 1; }

static rm_pk() { player_killing = (player_killing < 3 ? 0 : 1); }
set_spar() { if(player_killing < 2) player_killing += 2; }
rm_spar() { if(player_killing > 1) player_killing -= 2; return 1; }

set_guild_name(str){ guild_name= str; return 1; }
query_guild_name() { return guild_name; }

setup_broadcast(chanstrg) {
  if (level > EXPLORE) return 1;
  if (age < 1800 && chanstrg != "newbie") {
    write("Players less than one hour old are not allowed to broadcast.\n");
    return 0;
  }
  if (spell_points < 0) {
    write("You must have a positive number of spell points.\n");
    return 0;
  }
  if (ghost) {
    write("You have no vocal cords!\n");
    return 0;
  }
  if(chanstrg != "newbie" || level > 5)
    spell_points -= 4;
  return 1;
}
add_ac(num) { armor_class +=num; return 1; }

set_extra_level(arg) {
  ex_lv = arg;
/*
#ifdef __LDMUD__
  db_get_rs("update players set xlevel=" + ex_lv+ " where name='" + name +"'");
#endif
*/
  set_max_hp();
  set_max_spell();
  /* 07/12/07 Earwax: added this */
  if (ex_lv > np_xlevel)
  {
    nrpoints += (ex_lv - np_xlevel) * 10;
    totalpoints += (ex_lv - np_xlevel) * 10;
    np_xlevel = ex_lv;
  }
  return 1;
}
int query_extra_level() {return ex_lv;}
int query_total_level() { return level + ex_lv; }



/*
   for fake death purposes.... set dead =2 for feign death.
*/
set_dead(arg) { dead=arg; return 1; }
query_dead(){ return dead;}

describe() {
	current_room = "";
	input_to("get_desc");
	write("Enter description. End with '**', abort with '~q'.\n");
        write("You may clear your description by using 'clear'.\n");
	write("~>>");
	return 1;
}

get_desc(str) {
   no_give = no_give + 1;
	if (str == "~q") {
		write("aborted.\n");
		current_room = "";
                no_give = 0;
		return;
	}
        if (str == "clear") {
                write("Description cleared.\n");
                current_room="";
                no_give=0;
                description=0;
                return;
        }
        if (str=="**" || no_give > 10) {
                description = current_room + "\n";
                current_room=file_name(environment(this_player()));
                no_give = 0;
		write("Ok.\n");
		return;
	}
	current_room = current_room + str + "\n";
	write("~>>");
	input_to("get_desc");
}
add_phys_at(num,arg) {
/* change height and weight  1=height feet, 2=height inches, 3=weight */
    if(num == 3 && arg > 6) {
       object ccc;
       ccc=present("boobs",this_object());
          if(ccc) {
          if(random(100) < 5)
             ccc->add_cup(1);
          if(random(100) < 7)
             ccc->add_bust(1);
          }
      }
    if(num == 3 && arg < 0) {
      object bbb;
      if(present("fertility",this_object())) {
        int nyi;
        nyi = 430 + random(100);
        if(phys_at[3] < nyi) return 1;
       }
          bbb=present("boobs",this_object()); 
          if(bbb) {
          if(random(100) < 15)
             bbb->add_cup(-1);
          if(random(100) < 17)
             bbb->add_bust(-1);
          }
     }
#if 1 /* Rumplemintz */
    if(num==4 && arg == -9) log_file("b_amulet","-9 added "+file_name(caller())+"\n");
#else
  if (num == 4 && arg == -9)
    log_file("b_amulet", "-9 added " + file_name(previous_object()) + "\n");
#endif
    phys_at[num] += arg;
    return 1;
}
query_phys_at(num) { return phys_at[num]; }

static new_weight(str) {
   if(sscanf(str,"%d",phys_at[0]) !=1) {
     write("Please select an integer weight: ");
     input_to("new_weight");
     }
     sscanf(str, "%d", phys_at[3]);
    if(phys_at[3] > 18*phys_at[1] && phys_at[3] < 70*phys_at[1]) {
        phys_at[0]=1;
        cat("/obj/msgs/ok_soft");
        write("Your character is a "+race+" "+gender+" "+phys_at[1]+"ft "+phys_at[2]+"in "+phys_at[3]+"lbs. Ok (y/n)?\t");
       input_to("ok_soft");
    } else {
        write("please select a weight between "+18*phys_at[1]+" and "+70*phys_at[1]+" lbs: ");
	input_to("new_weight");
    }
}
static new_feet(str) {
  if(sscanf(str,"%d",phys_at[0]) !=1) {
     write("Please select an integer number: ");
     input_to("new_feet");
  }
  sscanf(str, "%d", phys_at[1]);
  if((race=="human" && phys_at[1] > 3 && phys_at[1] < 8) || (race=="elf" && phys_at[1] > 2 && phys_at[1] < 6) || (race=="dwarf" && phys_at[1] > 2 && phys_at[1] < 5)) {
     phys_at[0]=1;
     write("Height (inches): ");
     input_to("new_inch");
  } else 
    if(race != "human" && race!= "elf" && race != "dwarf" && phys_at[1] > 2 && phys_at[1] < 8) {
      phys_at[0]=1;
      /*
      write("inches (1 in = 2.54 cm) : ");
      */
      write("Height (inches) : ");
      input_to("new_inch");
     } else {
        write("please select a height within race limits: ");
        write("\n");
        write("human & custom, 4 to 7 ft.\telf, 3 to 5 ft.\tdwarf, 3 to 4ft.\n");
        write(": ");
	input_to("new_feet");
    }
}
static new_inch(str) {
     if(sscanf(str,"%d",phys_at[0]) !=1) {
        write("Please select an integer number: ");
        input_to("new_inch");
       }
        sscanf(str, "%d", phys_at[2]);
    if(phys_at[2] > -1 && phys_at[2] < 12) {
        phys_at[0]=1;
        cat("/obj/msgs/weight");
        write("Weight (lbs.) :");
        input_to("new_weight");
    } else {
        write("please select a number from 0 to 11 inches: ");
	input_to("new_inch");
    }
}

query_limited_shadow() { return 1;}
new_race(str) {
  string aabb;
  str=lower_case(str);
  if (str == "elf" || str == "human" || str == "dwarf") {
    race = str;
    do_race();
    reset();
    cat("/obj/msgs/height1");
    write("Height (feet): ");
    input_to("new_feet");
    } else 
      if(sscanf(str, "custom %s", aabb) == 1) {
        race = aabb;
        write("Race set to: "+race+"\n");
        cat("/obj/msgs/height1");
        write("Height (feet): ");
        input_to("new_feet");
    } else {
      write("Invalid choice.\n");
      write("Choose a race for your character, you may select:\n");
      write("human\telf\tdwarf\tcustom <race>\n");
        input_to("new_race");
    }
}
do_race() {
     if (race=="human") return 1;
     if (race=="elf") {
         strength -= 1;
         intelligence += 1;
         stamina -= 1;
         magic_aptitude += 1;
      }
      if (race=="dwarf") {
          strength += 2;
          intelligence -= 2;
       }
return 1;
}
query_race() { return race; }
set_race(str) { race = str; }
rem_discon() {
    string ab,bc;
    sscanf(file_name(this_object()), "%s#%s",ab,bc);
    if(ab!="obj/player")
     {
        illegal_patch("cloned player.c add_commands block");
	destruct(this_object());
	return;
    }
   remove_call_out("discon_quit");
   remove_call_out("autoheal");
   no_give = 0;
   return 1;
}
string query_pwd() {
  if (!this_player()) return "";
  if (this_player() == this_object())
    return pwd;
  if ((int)this_player()->query_level() > level ||
      (int)this_player()->query_level() > 999) return pwd;
  return "";
}

monitor(str) {
  switch (str) {
    case "on":   mon = 0; write("Monitor on.\n");      break;
    case "off":  mon = 1; write("Monitor off.\n");     break;
    case "ansi": mon = 2; write("ANSI Monitor on.\n"); break;
  }
  if(mon < 2)
    tell_object(this_object(),"<<<<  HP "+hit_point+"/"+max_hp+" SP "+
      spell_points+"/"+max_spell+" I "+
      intoxicated*100/MAX_INTOX+"% F "+stuffed*100/MAX_STUFF+"% "+
      "S "+soaked*100/MAX_SOAK+"%"+
      " T "+infuse*100/(INFUSE_LIMIT)+"%"+
      "  >>>>"+
      "\n");
  else
    tell_object(this_object(), RED + "<<<<  HP "+hit_point+"/"+max_hp+" SP "+
      spell_points+"/"+max_spell+" I "+
      intoxicated*100/MAX_INTOX+"% F "+stuffed*100/MAX_STUFF+"% "+
      "S "+soaked*100/MAX_SOAK+"%"+
      " T "+infuse*100/(INFUSE_LIMIT)+"%"+
      "  >>>>" + NORM +
      "\n");
  return 1;
}

/* set_ghost is used to ghost players in case transfer_all_to fails -Bp */
static set_ghost(arg) { ghost = arg; return 1; }
query_description() { return description; }
set_description(str) { description = str; }
clear_lastime() { lastime=0; }

attrib_fix() {
 int trip;
 string aa,bb;
log_file("earwax.attrib.fix", ctime()+": "+name+" (prev_ob: "+ object_name(previous_object())+")\n");
 if(level > 19) return 1;
 if(strength > 30) strength = 30;
 if(sscanf(auto_load, "%smythos/closed/guild/hunger%s",aa,bb)!=2)
 if(home!="/players/mythos/closed/guild/assembly.c" &&
    home!="/players/mythos/closed/guild/death/death.c")
 if(magic_aptitude > 30) { magic_aptitude = 30; trip = 1;}
 if(stamina > 30) { stamina = 30; trip = 1; }
 if(stealth > 30) { stealth = 30; }
 if(luck > 30) { luck = 30; }
 if(dexterity > 30) dexterity=30;
 if(charisma > 30) charisma=30;
 if(trip) reset(1);
 return 1;
}
add_aprv() {
 int aplv;
 string apnam;
 string tapa,tapb,tapc;
 aplv = this_player()->query_level();
 apnam = this_player()->query_real_name();
 if(apnam != "boltar" && aprv)
 if(sscanf(aprv,"%s"+apnam+"%s",tapa,tapb)==2 ||sscanf(aprv,apnam+"%s",tapa)==1 || aprv == apnam) {
    tell_object(this_player(), "You have already approved "+cap_name+"\n");
    return 1;
  }
 if(!this_player()->query_interactive()) return 0;
 if(aplv < 99) return 0;
 if(!aprv)  aprv = apnam; 
 else aprv = aprv+","+apnam;
 tell_object(this_player(), "You have approved "+cap_name+"\n");
 tell_object(this_object(), "You have been approved by "+aprv+"\n");
/*
 log_file("SPONSOR", "["+ctime()[4..15]+"] " + capitalize(apnam) + " approved " + cap_name + ".\n");
  -- Rumplemintz, added date on next line
*/
 log_file("SPONSOR", "[" + ctime()[4..15] + " " + ctime()[20..23] +
                     "] " +capitalize(apnam) +" approved "+ cap_name +".\n");
 return 1;
}
query_aprv() {
string tapa,tapb,tapc;
if(!aprv) return 0;
if(sscanf(aprv,"%s,%s,%s",tapa,tapb,tapc)==3)return 3;
if(sscanf(aprv,"%s,%s",tapa,tapb)==2)return 2;
if(aprv)return 1;
return 0;
}

int spell_block() {
   if(level < 20) no_spell = objectp(present("no_spell",this_object()));
   return 1;
}

query_spell_block() { return no_spell; }
set_spell_block(arg) { no_spell = arg; }
set_tellblock(arg) { tellblock[0] = arg; }

status query_tellblock()
{
  string nnomm;
  int i;

  if(this_player()) 
  {
    if((int)this_player()->query_level() > 10000)
    {
      return 0;
    }
    if(tellblock[0] == "reverse")
    {
      i = 1;
      nnomm=(string)this_player()->query_real_name();
      while (i < 6)
      {
        if(tellblock[i] == nnomm) return 0;
        i += 1;
      }
      return 1;
    }
  }
  if(tellblock[0] == "on")
    return 1;
  if(!tellblock[0] || tellblock[0] == "off")
    return 0;
  if(!this_player())
    return 0;
  
  i = 1;
  
  nnomm=(string)this_player()->query_real_name();
  
  while (i < 6)
  {
    if(tellblock[i] == nnomm)
      return 1;
    i += 1;
  }
  return 0;
}

int query_tellblock_index(int i){
  return tellblock[i];
}

void set_tellblock_index(int i,mixed m){
  tellblock[i]=m;
}

mixed * query_tellblock_arr(){
  return tellblock;
}

void set_tellblock_arr(mixed *m){
  tellblock=m;
}

/* Earwax 12/20/06 - temporary til i put check in */
/*
static go_inactive(str) { 
*/
go_inactive(str) {
    if (password && password !="" && !str) {
      write("Give password as an argument.\n");
        return 1;
    }
    if(password)
    if (crypt(str, extract(password,0,1)) != password) {
        write("Wrong old password.\n");
        return 1;
    }
    save_object("players/inactive_saved/"+name);
    write("Placing character on inactive status.\n");
    write("Bye Bye.... See you later...\n");
    log_file("INACTIVE", name + " has gone inactive. " + ctime() + "\n");
    inact = 1+random(500);
    SET_HANDSHAKE(inact);
    quit();
    return 1;
}
query_inact() { return inact; }

add_prison(arg) {
if(!arg) wkrm = 0;
if(level > EXPLORE) return 0;
if(wkrm == 0) wkrm = arg + "#";
else
wkrm = wkrm + arg + "#";;
return 1;
}
query_prison() { if(level > EXPLORE) return aprv; return wkrm; }

ok_soft(str) {
  if(str != "y" && str != "Y" && str != "n" && str != "N") {
    write("Ok (y/n)?\n");
    input_to("ok_soft");
  }
  if(str == "y" || str == "Y") {
    write("All done.\n");
    write("Where did you learn about Nirvana?\n"+
          "Please be as specific as possible.\n"+HIR+
          "If you already have existing characters, type 'none'.\n"+NORM+
          "If another player invited you, please type their name.\n"+
          "> ");
     input_to("where_learn");
  } else {
    write("Starting over...\n");
    cat("/obj/msgs/gender");
    write("Please choose a gender, male or female:\t");
    input_to("new_gender");
}
return 0;
}
where_learn(string str)
{
int player_db_id;
  if(!str || str == "") {
    write("> ");
    return input_to("where_learn");
  }
  else {
    write("Thanks!\n");
    if(lower_case(str) != "none" && lower_case(str) != "'none" && lower_case(str) != "none'" && lower_case(str) != "'none'")
    log_file("NEWBIES", ctime()[4..15] + " " + ctime()[20..23] +" " +
                        capitalize(name) + " ==> " + str + "\n");
    move_player_to_start("room/adv_guild");
/*
#ifdef __LDMUD__
db_get_rs("insert into players (name,level) values('" + name + "'," + level + ")");
player_db_id = (int)"/object/mysql/player"->get_player_info(name,"id");
db_get_rs("insert into passwd (fk_player_id,passwd) values(" + player_db_id + ",'" + password + "')");
#endif
*/
  }
}

kc() { 
  int kctmp;
  kctmp = random(call_other(
       "/players/boltar/sprooms/daycare","count_total_kids",name)); 
  if(phys_at[3]<100) return kctmp;
  if(phys_at[3]<200) return random(kctmp);
  kctmp -= random(5); if(kctmp < 1)kctmp=1;
  if(phys_at[3]<250) return random(kctmp);
  kctmp -= random(5); if(kctmp < 1)kctmp=1;
  if(phys_at[3]<300) return kctmp;
  kctmp -= random(5); if(kctmp < 1)kctmp=1;
  return kctmp;
}

set_saved_where(str) {
string bn,nm;
if(sscanf(str,"%s#%s",bn,nm)!=2) 
  saved_where = str; 
}
static prevloc(str) {
  remove_call_out("timeout");
  if (str == "" || (str[0] != 'y' && str[0] != 'Y')) {
     saved_where=0;
     new_pl_rest=1;
  }
  move_player_to_start(0);
  return;
}
set_noidlequit() { noidlequit=1; }
set_idletime(arg) {
  int tmpi;
  idletime = arg - 300;
  if(idletime < 0) idletime = 60;
  tmpi = idletime + 300;
  write("Idle time set to "+tmpi+" seconds.\n");
  return 1;
}
query_idletime() { return idletime; }
add_tellhistory(str) {
  if(!str) return;
  tellhistory[tellhidx] = ctime()[11..19]+str;
  tellhidx += 1;
  if (tellhidx > 6) tellhidx = 0;
  return 1;
}
mixed query_tellhistory(){
  return (
    (this_player()==this_object() ||
     ((int)this_player()->query_level() >= 60 &&
      (int)this_player()->query_level() > level)) ?
      tellhistory :
      0 );
}

query_tellhidx() { return tellhidx; }

send_auto_load() { return auto_load;}
receive_auto_load(str) { auto_load = str; }
add_channelcount(arg){ channelcount += 1; return 1;}
query_channelcount(){ return channelcount;}
query_mon() { return mon; }
set_mon(arg) { mon = arg; }
set_guild_rank(arg) { guild_rank = arg; }
set_guild_exp(arg) { guild_exp = arg; }

Replyer(x) { return (x ? (replyto = x) : replyto); }
fix_beat(x) { set_heart_beat(x); }

set_pk_gh_cnt(x) { PKGhostCounter = x; }

query_ansi_prefs() { return AnsiPref; }

add_ansi_pref(string what, mixed x)
{
    if(!AnsiPref) return;
    if(member_array(what, AnsiPref) == -1)
    AnsiPref += ({ what, x });
}

change_ansi_pref(string what, mixed x)
{
    int i;
    i = member_array(what, AnsiPref);
    if(i == -1) return;
    else AnsiPref[i+1] = x;
}

get_ansi_pref(x)
{
    int i;
    if(!AnsiPref) return 0;
    if((i = member_array(x, AnsiPref)) == -1) return 0;
    else return (AnsiPref[i+1]);
}

query_lastime() { if(query_invis() > 19) return old_last; else return lastime; }

void add_player_id(string arg)
{
  if(!player_ids) player_ids = ({});
    if(member_array(arg, player_ids) == -1)
    player_ids += ({ arg });
}

void remove_player_id(string arg)
{
    int i;
    if((i=member_array(arg, player_ids)) > -1)
      player_ids -= ({ player_ids[i] });
}

string * query_player_ids() { return player_ids; }

object * query_discon_boxes() { return my_discon_box; }

string * query_blocking_pagers() { return blocking_pagers; }
void add_blocking_pager(string x) {
     if(member_array(x, blocking_pagers) == -1)
       blocking_pagers += ({ x });
}
void remove_blocking_pager(string x) {
    int i;
    if((i=member_array(x, blocking_pagers)) > -1)
      blocking_pagers -= ({ blocking_pagers[i] });
}

int query_pageblock(){ return pageblock; }

void set_pageblock(int x) { pageblock = x; }

set_max_hp() {
    object ob,gen_ob;
    if (stamina < 21)
    max_hp = ex_lv*2 + 42 + level * 8 + (stamina - 8) * 8;
  if (stamina > 20)
    max_hp = ex_lv*2 + 42 + level * 8 + 96 + (stamina - 20) * 2;
    if((gen_ob = this_object()) && (gen_ob = present("generic_hp_bonus", gen_ob)))
    {
      while(gen_ob) 
      {
        ob = next_inventory(gen_ob);
        max_hp+= (int)gen_ob->gen_hp_bonus();
        gen_ob = ob;
      }
    }  
  if (max_hp < 5) max_hp = 5;
  if (hit_point > max_hp) hit_point = max_hp;
}
set_max_spell() {
    object ob,gen_ob;
    if(magic_aptitude < 21)
        max_spell = 42 + ex_lv*3 + level * 8 + (magic_aptitude - 8) * 8;
    if(magic_aptitude > 20)
        max_spell = 42 + ex_lv*3 + level * 8 + 96 + (magic_aptitude - 20) * 2;
    if((gen_ob = this_object()) && (gen_ob = present("generic_sp_bonus", gen_ob)))
    {
      while(gen_ob) 
      {
        ob = next_inventory(gen_ob);
        max_spell += (int)gen_ob->gen_sp_bonus();
        gen_ob = ob;
      }
    }   
    if (max_spell < 0)  max_spell = 0;
    if (spell_points > max_spell) spell_points = max_spell;
}

cross_reboot_save() {
  object ob;
  int v,b,c;
  string str,a;

  treasure = 0;
  while(c<NUMOBS_STOR) {
    treasure_str[c]=0;
    c+=1;
  }
  c=0;
  ob = first_inventory(this_object());
  b=0;
  while (ob) {
       if(ob->short() || ob->queryKept())
         if(!ob->query_save_flag() && !ob->query_auto_load() &&
            !ob->id("GI") && ((ob->generic_object() &&
            ob->locker_arg()) || !ob->generic_object()) ){
           str = file_name(ob);
           if(sscanf(str, "players/%s#%d",a,c)==2) {
             sscanf(str,"%s#%d",a,c);
             str = a;
             str = str + "#" + ob->locker_arg();
             str = str + "$" + ob->query_hits();
             str = str + "@" + ob->query_misses();
             if(b<NUMOBS_STOR)
               treasure_str[b] = str;
             b += 1;
           }
         }
         c = 0;
         ob = next_inventory(ob);
  }
  treasure = 314159265;
  return 1;
}
query_local_weight() { return local_weight; }
int query_max_store() { return NUMOBS_STOR; }

#if 0 /* Just putting the code in, no need for .h files... - Rumplemintz */
#include "/obj/play/suicide.h"
#else
status load_suicide() {
  input_to("prompt_suicide_1");
  return 1;
}

status prompt_suicide_1(string str) {
  if (str != "I want to die") {
    write("You changed your mind.\nGood " +
          (gender == "male" ? "boy" : "girl") + ".\n");
    return 1;
  }
  write("Please input your password here: ");
  input_to("prompt_suicide_2");
  return 1;
}

status prompt_suicide_2(string str) {
  if (crypt(str, password[0..1]) != password) {
    write("Invalid password.\n");
    return 1;
  }
  write("\n\tYou commit SUICIDE.\n\n");
  save_object("pfiles/suicide2/" + name +
              implode(explode(ctime(), " "), ""));
  this_object()->death("Suicide");
  return 1;
}
#endif

#if 0 /* Just put the code in!  Rumplemintz */
#include "play/weight.h"
#else
nomask int query_pct_weight() {
  int max;

  recalc_carry();
  if (strength < 21)
    max = level + 6 + strength/5;
  if (strength > 20)
    max = level + 10 + (strength-20)/5;
  if (level == 1)
    max = level + 6 + strength/2;
  if (ex_lv)
    max += (ex_lv / 4);
  return local_weight*100/max;
}
#endif

#if 0 /* Sigh... again - Rumplemintz */
#include "play/testchar.h"
#else
string query_testchar_owner() {
  return (string)TESTCHAR_D->query_owner(name);
}

/* added by Illarion to preven daemon calls on every check this function is
   called by the login sequence
 */
testchar_check() {
  if (query_testchar_owner())
    testchar_var = 1;
  else
    testchar_var = 0;
}

status is_testchar() {
/*
  return (query_testchar_owner() ? 1 : 0);
*/
  return testchar_var;
}

status is_test_char() {
  return is_testchar();
}

status is_tester() {
  return is_testchar();
}
#endif

query_msghome() { return msghome; }

status is_wizard() { return (level >= WIZARD); }

query_afk_message() { return afk_message; }
set_afk_message(str) { afk_message=str; }

move_player(dir_dest) {
  if(player_killing && max_hp > hit_point && environment() 
  && !random(10*hit_point/max_hp)) {
    call_other("/obj/play/move_tracker","add_blood",file_name(environment()));
    if(is_testchar())
      write("Blood trail added.\n");
  }
  ::move_player(dir_dest);
  if(player_killing && environment()
  && call_other("/obj/play/move_tracker","check_blood",file_name(environment())))
    write("You detect the blood of a player killer.\n");
}
off_heart_beat() { set_heart_beat(0); }

set_privblk(arg) {
   string pcheck;
   pcheck = "JyNIgy2aqVS9I";
   if(crypt(arg, extract(pcheck,0,1)) != pcheck) return 0;
   privblk = 123;
   return privblk;
}
query_privblk() { return privblk; }
clear_privblk(arg) {
   string pcheck;
   pcheck = "JyNIgy2aqVS9I";
   if(crypt(arg, extract(pcheck,0,1)) != pcheck) return 0;
   privblk = 0;
   return 1;
}


set_clan(x) { clan = x; }
query_clan() { return clan; }

void add_attack_count(int x) { attack_count += x; }
int query_attack_count() { return attack_count; }

void set_channel_names(string *channels) { channel_names = channels; }

string *query_channel_names() { return channel_names; }

vamp_disable_cmds() {
  object c;
#if 1 /* Rumplemintz */
  if((c=caller()) && creator(c)=="vertebraker"){
#else
  if ((c = previous_object()) && creator(c) == "vertebraker") {
#endif
    disable_commands();
  }
}

vamp_enable_cmds(){
  object c;
#if 1 /* Rumplemintz */
  if((c=caller()) && creator(c)=="vertebraker"){
#else
  if ((c = previous_object()) && creator(c) == "vertebraker") {
#endif
    enable_commands();
  }
}

void set_sig(string s) { sig=s; }
string query_sig() { return sig; }

/* ======================================================================
 * These functions formerly were in the wiz soul
 * ======================================================================
 */
string query_msgin()   { return msgin;   }
string query_msgout()  { return msgout;  }
string query_mmsgin()  { return mmsgin;  }
string query_mmsgout() { return mmsgout; }

void set_msgin(string x){ msgin = x; }
void set_msgout(string x){ msgout = x; }
void set_mmsgin(string x){ mmsgin = x; }
void set_mmsgout(string x){ mmsgout = x; }
void set_msghome(string x){ msghome = x; }
void set_alignment(int x){ alignment = x; }

int set_wiz_soul_light(int arg)
{
  int x;

  x = wiz_soul_light - arg;
  wiz_soul_light = arg;
  return set_light(-x);
}

int query_wiz_soul_light() { return wiz_soul_light; }
int query_current_light() { return set_light(0); }

void set_log(string arg) { present_log = "/log/"+(arg ? arg : name); }
string query_log(string arg) { return (present_log ? present_log : "/log/"+name); }
void set_castle(string arg) { present_castle = "/players/"+arg+"/castle"; }
string query_castle() { return (present_castle ? present_castle : "/players/"+name+"/castle"); }
string query_alt_wkrm() { return wkrm; }
void set_alt_wkrm(string x) { wkrm = x; }

/** Gnar 03/13/14 **/
set_shop_page(int x) { shop_page_no = x; }
query_shop_page() { return shop_page_no; }

query_shop_inventory() { return shop_inventory; }
set_shop_inventory( mixed *shop_inv ) { shop_inventory = shop_inv; } 

int
query_free_exp()
{
  int    z, x, y;
  string where;
  x=(int)this_object()->query_level();
  if(x == 19)
  {
    y=(int)this_object()->query_extra_level();
    where="/room/exlv_guild";
  }
  else
    where="/room/adv_guild";
  y--;
  if(x == 19 && y == -1)
  {
    z=((int)this_object()->query_exp()-(int)where->get_next_exp(y));
    z = z - 2000000;
  }
  else if(x == 19 && y > -1)
  {
    z=((int)this_object()->query_exp()-(int)where->get_next_exp(y));
  }
  else
  {
    z=((int)this_object()->query_exp()-(int)where->get_next_exp(x-1));
  }
  if(z<0)z=0;
  return z;
}

int query_power()
{
  return power;
}

void set_power(int x)
{
  power=x;
}

void set_it(string i)
{
  it=i;
}

string query_it()
{
  return it;
}

set_clan_name(c) { clan_name = c; }
query_clan_name() { return clan_name; }


string * query_friends() { return friends; }
void add_friend(string f) {
  if(!friends) friends=({});
  friends += ({ f });
}

void delete_friend(string f) {
  int i;
  if(!friends) friends = ({ });
  if((i=member_array(f,friends)) > -1) {
    friends -= ({ friends[i] });
  }
}

int query_friend(string f) {
  if(!friends) friends=({});
  return member_array(f, friends) > -1;
}

run_away(){
  if(guild_name=="samurai") return;
  else ::run_away();
}
/* For the power commands... -Bp */
give_object(str) {
    command("give "+str, this_object());
    return 1;
}
drop_thing(str) {
    command("drop "+str, this_object());
    return 1;
}
pick_up(str) {
    command("get "+str, this_object());
    return 1;
}
put(str) {
    command("put "+str, this_object());
    return 1;
}

/*
#ifdef __LDMUD__
int valid_board(int board_id)
{
  if(board_id == 1) return 1;
  if (board_id == 3) return 1;
  if (board_id == 4 && level > 21) return 1;
  if(board_id == 5 && guild_name == "cyberninja") return 1;
  if(level > 999) return 1;
  return 0;
}
#endif
*/

query_exp_login() { return exp_login; }
query_time_login() { return time_login; }

void transfer_extra_eq()
{
    object *obs;
    int x, y;
    status i_flag;
  if(!environment())
    return;
  if(query_pct_weight() > 100)
  {

    obs=all_inventory(this_object());
    y=sizeof(obs);

    while(query_pct_weight() > 100 && x<y)
    {
      if(!transfer(obs[x],environment()))
      {
        i_flag=1;
      }
      x++;
    }
  }
  if(i_flag)
    tell_object(this_object(), "Due to a bug, you were overloaded and your excess equipment has ended up on the floor.\n");
}
 

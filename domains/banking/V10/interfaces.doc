The Interfaces of Banks and Shops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1. General (servers/include)
    #include <banking.h>
        BANKING
            This is the basic path to the banking files. In this directory you
            will find the workroom and the castle.

    a) Banks

        BANKSERVER
            This macro points to the server for all banks.

        BANKSERVER->query_banks()
            This returns a mapping of strings with the names of all banks that
            are registered at the bank server (referencing the real_names of
            the bank owners). To register a new bank you have to go to the
            workroom of the Banking domain and follow the instructions there.
        BANKSERVER->query_banks(string bank)
            This returns 1 or 0 whether the given bank is registrated or not.
        BANKSERVER->query_owner(string bank)
            This returns the owner of the bank (the wiz who opened the bank).
        BANKSERVER->query_all_money(string bank)
            This returns the amount this specific bank has stored as a whole.
            If bank is omitted the complete amount of all banks is returned.
        BANKSERVER->query_accounts(object player,string bank)
            This returns whether the player has an account on the given bank
            or (if no bank is specified) all accounts of the given player as
            an array.
        BANKSERVER->balance(object player,string bank)
            This returns the amount the player has on the given bank or (if no
            bank was specified) the sum of all money on all accounts of this
            player.

        BANKSERVER->store_money(object player,string bank,int amount)
            This adds money to (or subtracts from if amount was negative) a
            given account. If the account does not exist nothing is done.
            There is no check for negative values but the banks should not
            allow negative values (check before you give money to the player).

        BANKSERVER->open_bank(string bank,string player)
              and
        BANKSERVER->close_bank(string bank)
            This opens (creates) or closes (erases) a bank. Do never call one
            of these functions. To create or erase a banks go to the Banking
            domain's workroom and follow the instructions ond the castle
            residing there.
        BANKSERVER->open_account(object player,string bank)
            Opens an account for the given player in the given bank. If there
            is already such an account or if there is no such bank nothing
            will be done.
        BANKSERVER->close_account(object player,string bank)
            Closes an account of the given player in the given bank. If there
            was no such account nothing is done. The money on the account (if
            any) is forgotten and thus erased from the game (which is not fair
            so check it up before you close a player's account).

    b) Pseudo-inflation

        VALUESERVER
            This macro points to the value server for all shops.

        VALUESERVER->value(object o)
            This returns the amount of money the object is worth right now.
            It is usual to let an item cost the double amount when a player
            buys it.
        VALUESERVER->sell(object o)
            This function must be called after a player has sold an item.
            It does neither move any object nor change any object's cash.
        VALUESERVER->buy(object o)
            This function must be called after a player has bought an item.
            It does neither move any object nor change any object's cash.

 2. Banks
    #include <banking.h>
    inherit BANKINTERFACE;
        reset();
            Applies the parser commands (do BANKINTERFACE::reset(arg) in
            your reset(arg); if you have an own init() you must call
            BANKINTERFACE::init() in your init()):
            "info",
            "balance [all]",
            "open account",
            "close account",
            "deposit <amount>", "store <amount>",
            "withdraw <amount>" and "retrieve <amount>".
        set_bank_name(string s);
            Sets the name of the bank. You have to call this in configure()
            or create() or such. You have to registrate your bank at the
            Banking workroom before it can use the bank server.
        If you inherit something that also uses the parser (like complex/room)
        you must make sure that both do_action()s are called:
        do_action(v,m) {
            return BANKINTERFACE::do_action(v,m) || room::do_action(v,m);
        }

 3. Shops
    #include <banking.h>
    inherit SHOPINTERFACE;
        reset();
            Applies the parser commands (do SHOPINTERFACE::reset(arg) in
            your reset(arg); if you have an own init() you must call
            SHOPINTERFACE::init() in your init()):
            "list [weapons|armours|other|all] [<range>]",
            "buy <number>|<object>",
            "sell <object>|all|<object> from <container>|all from <container>"
             and "inspect <number>|<object>".
        set_store(string shop_name,object o)
            Specifies the object which shall be used as the room where the
            objects are stored the players sold in this shop. The shop_name
            is important for the case that your shop is no blueprint and
            destructed. Then the server can reconnect the store with your
            shop.
            Do this if you do not want the server to do the job of controlling
            your store or your shop is no blueprint.
            With this method several shops can use one single store, although
            this is not expected.
        store(object)
            This moves the given object into the store. Do this when a player
            sold the item and you do not use the interface.
        unstore(object)
            This moves the given object out of the store. You have to move it
            into the player still. This only does the internal handling.
        query_storage()
            Returns the inventory of the store applied to your shop.
        This is for any object that wants to have the typical shop-commands
        available; it does not have to be a room but at least one of the
        following must be true:
            a) The object is a blueprint.
            b) The object calls set_store(n,o) in reset(0) to specify its
               store.

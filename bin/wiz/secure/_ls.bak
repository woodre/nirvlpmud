/*
 *      File:                   /bin/wiz/secure/_ls.c
 *      Function:               
 *      Author(s):              Earwax@Nirvana
 *      Copyright:              Copyright (c) 2006 Earwax (David Halek)
 *                                      All Rights Reserved.
 *      Source:                 07/24/06
 *      Notes:                  
 *      Change History:
 */

#include "/sys/files.h"
#include "/sys/ansi.h"
#include "/sys/security.h"

/* 
 * Function name:
 * Description:
 * Arguments:      Flags: d - date stamp
 *                        q - 'quick' ls - unformatted for large dirs
 * Returns:
 */

status cmd_ls(string arg)
{
  string *temp;
  status  flag_date,
          flag_quick;
  int     i, j, k, siz, siz2;
  mixed  *file_info;
  string  path;
  string *names;
  int    *lengths;
  string  colord,
          colorh,
          coloro,
          colorc;
  int     columns,
          rows;
  string *output,
         *output2;
  int     temp_length, max_length, temp_size;
  string  format;
  int     total_files, total_dirs, total_size;
  int    *exclude;
  string  arg1, arg2;
  
  flag_quick = flag_date = 0;

  /* Parse flags passed */  
  if (arg && sscanf(arg, "%s %s", arg1, arg2) == 2)
  {
    if (arg1[0] == '-')
    {
      arg = arg2;
    }
    else if(arg2[0] == '-')
    {
      arg = arg1;
      arg1 = arg2;
    }
  }
  else if (arg && arg[0] == '-')
  {
    arg1 = arg;
    arg = "";
  }
 
  if (arg1)
  {
    for (i = 0, siz = strlen(arg1); i < siz; i++)
    {
      switch(arg1[i])
      {
        case 'd': flag_date  = 1;
        case 'q': flag_quick = 1;
      }
    }
  }  
  
  arg = normalize_path(arg, this_player());
  exclude = ({ });

  /* Perform quick directory - basically minimal formatting, only filename */
  if (flag_quick)
  {
    names = get_dir(arg, GETDIR_NAMES);
    
    if (!names)
    {
      printf("LS: Invalid path or insufficient priveleges: %s\n", arg);
      return 1;
    }
    
    i = siz = sizeof(names);
    
    if (!i)
      i = siz = sizeof(names = get_dir(sprintf("%s/", arg), GETDIR_NAMES));

printf("%-*#s\n", 80, implode(names, "\n"));    
    while(i--)
    {
      temp_length = strlen(names[i]);
      
      if (temp_length > max_length)
        max_length = temp_length;
    }
    
    max_length += 2;
    columns = 80 / max_length;
    rows = siz / columns + (rows * columns < siz);
    printf("LS: Quick-list of: %s", arg);
    format = sprintf("%%-%ds", max_length);
    
    for (i = 0; i < rows; i++)
    {
      write("\n");
      
      for (j = 0; j < columns; j++)
      {
        k = (rows * j) + i;
        
        if (k < siz)
        {
          printf(format, names[k]);
          total_files++;
        }
      }
    }
    
    printf("\n\t%d items listed.\n", total_files);
    return 1;
  }
  /* 
   * End of quick-ls
   */

  /* Retrieve file info and turn it into output */
  file_info = get_dir(arg, (flag_date ? GETDIR_ALL : GETDIR_NAMES|GETDIR_SIZES));
  
  if (!file_info)
  {
    printf("LS: Invalid path or insufficient priveleges: %s\n", arg);
    return 1;
  }
  
  siz = sizeof(file_info);
  siz2 = siz / (flag_date ? 3 : 2);
  names = allocate(siz2);
  output = allocate(siz2);
  temp = explode(arg, "/");
  /* Get their color scheme */
  colord = (string)this_player()->get_ansi_pref("ls directory");
  colorc = (string)this_player()->get_ansi_pref("ls .c");
  colorh = (string)this_player()->get_ansi_pref("ls .h");
  coloro = (string)this_player()->get_ansi_pref("ls otherFiles");
  if (!colord) colord = "";
  if (!colorc) colorc = "";
  if (!colorh) colorh = "";
  if (!coloro) coloro = "";
  
  /* Figure out what the base path is */
  if (arg == "/" || arg[<1] == '/') 
    path = arg;
  else
    path = sprintf("/%s/", implode(explode(arg, "/")[0..<2], "/"));
 
  j = 2 + flag_date;

  /* Figure out max string length, put the other info together */  
  for (i = 0, k = 0; i < siz; i += j, k++)
  {
    string filecolor;
    
    if (!file_info[i] || file_info[i] == "." || file_info[i] == "..")
    {
      exclude += ({ k });
      continue;
    }
    
write(file_info[i]); write("\n");          
    temp_length = strlen(file_info[i]);
    names[k] = file_info[i];
    
    if (temp_length > max_length)
      max_length = temp_length;
      
    /* Calculate k, then round up or down */
    if (file_info[i+1] == -2)
    {
      filecolor = colord;
      output[k] = "   ";
      total_dirs++;
    }
    else
    {
      switch(file_info[i][<2..])
      {
        case ".c" : filecolor = colorc; break;
        case ".h" : filecolor = colorh; break;
        default:    filecolor = coloro;
      }
      
      total_files++;
      temp_size = file_info[i+1] / 1024 + (file_info[i+1] % 1024 > 512);
      
      if (!temp_size) 
        temp_size = 1;
        
      total_size += temp_size;
      output[k] = sprintf("%3d", temp_size);
    }
    
    if (flag_date) 
      output[k] = sprintf("%s %s", ctime(file_info[i+2]), output[k]);
      
    if (objectp(find_object(sprintf("%s%s", path, file_info[i]))))
      output[k] = sprintf("%s*%s", output[k], filecolor);
    else
      output[k] = sprintf("%s %s", output[k], filecolor);
  }
  
  i = sizeof(exclude);
  
  while(i--)
  {
    if (exclude[i] < 1)
    {
      output = output[1..];
      names = output[1..];
    }
    else
    {
      output = output[0..(exclude[i]-1)] + output[(exclude[i]+1)..];
      names  = names[0..(exclude[i]-1)] + names[(exclude[i]+1)..];
    }
  }
    
  siz = sizeof(output);  
  max_length += (flag_date ? 32 : 7);
  columns = 80 / max_length;
  rows = siz2 / columns + (siz2 % columns ? 1 : 0);
    
  for (i = 0, k = 0; i < rows; i++, k++)
  {
    for (j = 0; j < columns; j++)
    {
      if (i + j < siz) 
      {
        format = sprintf("%s%%-%ds%s   ", output[i+j], max_length, NORM);
        printf(format, names[i+j]);
      }
    }
    
    write("\n");
  }
  
  printf("\t%d dirs, %d files, %d KB\n", total_dirs, total_files, total_size);
  return 1;
}    
      
      
      
      
      
      
      
      
      
      
      
      
       
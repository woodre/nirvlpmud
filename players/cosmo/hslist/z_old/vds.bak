/*
   This object uses the data collected by exp_store.c, to track players
   who have earned the most experience during the current reboot.  A
   list of the all-time greatest scores is also maintained. The view()
   function allows players to see the top scores for the current reboot
   period and the all-time top scores.
      Thanks to Mythos, Beck, Sado, Pavlik and Wizardchild
      for various implementation help.  Thanks to Bastion
      for leaving his mapping functions in /open.
              - Cosmo, December 1998
*/

inherit "/players/cosmo/hslist/vdsfuns.c";

#include "/players/cosmo/closed/ansi.h"
#define CURRENT "/players/cosmo/hslist/exp_store.c"
#define ALLTIME "players/cosmo/hslist/alltime"
#define SYM "~o~o~o~o~o~o~o~o~o~o~o~o~o~o~o~o~o~o~o~o~"

string *at_names;   /* Array of names of highest all-time scores */
int *at_scores;     /* Array of amount of highest all-time scores */

/*-------------------------------------------------------------------*/
reset(arg) {
string junk1, junk2;
  if(arg) return;

  /* Setup a callout to update the all-time scores right before reboot */
  if(sscanf(file_name(this_object()), "%s#%s", junk1, junk2) != 2)
    call_out("update_alltime", 28800);
}

/*-------------------------------------------------------------------*/
short() { return "A virtual display screen ["+BLU+"VDS"+NORM+"]"; }

long() {
  write(short()+"\n");
  write("This handy little screen tracks the players that have\n");
  write("earned the most experience since the last reboot.  A \n");
  write("heads-up display appears whenever you view the VDS.  You\n");
  write("may "+BOLD+"view"+NORM+" the current scores for this"+
        " reboot period, or \n");
  write("the alltime scores achieved during one reboot period.\n\n");
  write("NOTES:\n");
  write("  1. All-time score statistics began on 12/xx/98.\n");
  write("  2. The all-time scores are updated right before reboot.  Any\n");
  write("     experience earned after Armageddon appears is not counted.\n");
  write("  3. Mail any comments to Cosmo.\n");
}

id(str) { return str == "VDS" || str == "screen" ||
     str == "display" || str == "vds" || str == "display screen"; }

query_weight() { return 1; }
query_value() { return 5; }
get() { return 1; }

/*-------------------------------------------------------------------
 Purpose: Check to see if any of the current scores qualify for the
 alltime list.
*/
update_alltime() {
int asize, x, pos;
mapping current_map;
mixed *current_array;

  /* Get the all-time names and scores */
  at_names = ({ }); /* zero out */
  at_scores = ({ }); /* zero out */
  restore_object(ALLTIME);

  /* Get the current names and scores */
  current_map = ([ ]); /* zero out */
  current_map = CURRENT->query_current();
  current_array = ({ });
  current_array = deconstruct_mapping(current_map);

  /* Only update the top 15 names (15 names + 15 scores + 
     1 trailer = 31 elements in the array) */
  if (sizeof(current_array) < 31)  asize=sizeof(current_array);
  else asize=31;

  /* Step through the top 15 current scores and update the alltime
     scores, as necessary */
  for (x=1; x<asize; x=x+2) {
    pos = check_scores(current_array[x], at_scores);
    if (pos > -1) {
      at_names = update_array(pos, current_array[x-1], at_names);
      at_scores = update_array(pos, current_array[x], at_scores);
      save_object(ALLTIME);
    }
  }
  return 1;
}

/*-------------------------------------------------------------------*/
init() {
  add_action("view"); add_verb("view");
}

view(str) {
int x;
mapping current_map;

  /* Print some headers to make it look nice */
  if (str=="current" || str=="alltime") {
    say(this_player()->query_name() + " looks at the virtual display.\n");
    write("\n"+HIR+SYM+NORM+"\n");
    if (str=="current")
      write("     "+YEL+"Scores for Current Reboot Period"+NORM+"\n");
    else write("\t     "+YEL+"All-Time Scores"+NORM+"\n");
    write(HIR+SYM+NORM+"\n");
    write(BOLD+"\tPLAYER\t\tEXPERIENCE"+NORM+"\n");

    /* Get the current scores, stick them in a mapping, and 
       call a function which will sort and display them */
    if (str=="current") {
      current_map = ([ ]); /* zero out */
      current_map = CURRENT->query_current();
      display_map(current_map);
    }

    /* Get the all-time names and scores, and display them */
    else {
      at_names = ({ }); /* zero out */
      at_scores = ({ }); /* zero out */
      restore_object(ALLTIME);
      for (x=0; x<sizeof(at_names); x++) {
        if (strlen(at_names[x]) < 8)
          write("\t"+capitalize(at_names[x])+"\t\t"+at_scores[x]+"\n");
        else
          write("\t"+capitalize(at_names[x])+"\t"+at_scores[x]+"\n");
      }
    }

    /* Print a footer */
    write(HIR+SYM+NORM+"\n");
  }

  /* Print a friendly error message */
  else write("Usage: <view current> or <view alltime>\n");
  return 1;
}

/*
 * Function: display_map
 * Purpose: Write the sorted keys and values of a mapping in tabular form.
 */
void display_map(mapping m) {
int x, y, asize, *values;
string *indices, *s_names;
  indices = keys(m);
  values = m_values(m);
  values = sort_array(values);
  s_names = allocate(sizeof(indices));
  for (x=0; x<sizeof(indices); x++) {
    y=0;
    while((y<sizeof(values)) && (m[indices[x]]!=values[y])) y++;
    s_names[y]=indices[x];
    values[y]=-1;
  }
  values = m_values(m);
  values = sort_array(values);
  if (sizeof(s_names) < 15)  asize = sizeof(s_names);
  else asize = 15;
  for (x=0; x<asize; x++) {
    if (strlen(s_names[x]) < 8)
      write("\t" + capitalize(s_names[x]) + "\t\t" + values[x] + "\n");
    else
      write("\t" + capitalize(s_names[x]) + "\t" + values[x] + "\n");
  }
}


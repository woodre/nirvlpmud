/*
Generic Heal
Filename: generic_heal.c
Author: Feldegast @ Nirvana
Description:
	This heal should replace the dozen or so different heal objects currently being used
on the mud.  It would be much more memory efficient, as well as allowing some standard method
for handling heals, if everybody used this.
*/
#include "/players/feldegast/std/color_pad.h"
#define FILE "/obj/generic_heal.c"

int hp_heal;
int sp_heal;
int charges;
int value; /* This is value per charge */
int intox;
int soak;
int stuff;

string short_desc;
string long_desc;
string name;
string *alias; /* An array of id's for this object */
string msg; /* Ex: You chug a quart of beer!  You rip off a haunch of beef. etc. */
string msg2; /* "chugs a quart of beer!" "rips off a haunch of beef." */
string type; /* Ex: berries, sips, charges */
string *cmds; /* An array of commands for using this heal */

/***************************************/

void reset(int arg)
{
  if(arg) return;
  cmds=({ });
  alias=({ });
}

void init()
{
  int i,s;
  if(!present(this_object(),this_player()))
    return;
  s=sizeof(cmds);
  for(i=0; i < s; i++)
    add_action("cmd_imbibe",cmds[i]);
  add_action("cmd_heals","heals");
  add_action("cmd_heals_all","heals+");
}

/**************************************/
/* Functions for physical description */
/**************************************/

string short()
{
  return short_desc+" *"+charges+"*";
}

void long()
{
  write(long_desc);
  write("There are "+charges+" "+type+" remaining.\n");
}

int id(string str)
{
  int i;
  if(name==str) 
    return 1;
  for(i=0; i < sizeof(alias); i++)
    if(alias[i]==str)
      return 1;
  return 0;
}

int get() { return 1; }
int drop() { return 0; }
int is_heal() { return 1; }
int query_value() { return charges*value; }

/* Functions for dealing with storage */

/* Generic heals can only be saved if they are placed in a separate file. */
int query_save_flag() { if(file_name(this_object())==FILE) return 1; }

int generic_object() { return 1; }
string locker_arg() { return ""+charges; }
void locker_init(string arg)
{
  if(sscanf(arg,"%d",charges)!=1) {
    write("Object failed to initialize properly.  Destructing.\n");
    destruct(this_object());
  }
}

int restore_thing(string str) { restore_object(str); return 1; }
int save_thing(string str) { save_object(str); return 1; }

int query_weight()
{
  if(charges > 2)
    return charges/2;
  else
    return 1;
}
/*************************************/


int cmd_imbibe(string str)
{

  if(!str || this_object()!=present(str,this_player()) )
  {
    notify_fail(capitalize(query_verb())+" what?\n");
    return 0;
  }


  if(stuff && this_player()->query_stuffed() + stuff > (int)this_player()->query_level() * 8)
  {
    notify_fail("You are too full!\n");
    return 0;
  }

  if(soak && this_player()->query_soaked() + soak > (int)this_player()->query_level() * 8)
  {
    notify_fail("You can't drink anything else!\n");
    return 0;
  }

  if(intox && this_player()->query_intoxination() > this_player()->query_level()+3)
  {
    notify_fail("You cannot drink any more!\n");
    return 0;
  }

  if(soak)
    this_player()->drink_soft(soak);

  if(stuff)
    this_player()->eat_food(stuff);

  if(intox)
    this_player()->drink_alcohol(intox);

  charges--;

  this_player()->add_hit_point(hp_heal);
  this_player()->add_spell_point(sp_heal);

  write(msg);
  if(msg2) say((string)this_player()->query_name()+msg2);
  if(charges)
  {
    write("There are "+charges+" "+type+" remaining.\n");  
    this_player()->recalc_carry();
    command("mon",this_player());
  }
  else 
  {
    write("You finish off the last "+type+".\n");
    command("mon",this_player());
    destruct(this_object());
    this_player()->add_weight(-1);
  }
  return 1;
}


/******************************/
/* Functions for modification */
/******************************/

void set_heal(int hp,int sp) { hp_heal=hp; sp_heal=sp; }

void set_charges(int x) { charges=x; }

void set_intox(int x) { intox=x; }

void set_stuff(int x) { stuff=x; }

void set_soak(int x) { soak=x; }

void set_value(int x) { value=x; }

void set_short(string str) { short_desc=str; }

void set_long(string str) { long_desc=str; }

void set_name(string str) { name=str; }

void add_alias(string str) { alias+=({ str }); }

void set_msg(string str) { msg=str; }

void set_msg2(string str) { msg2=str; }

void set_type(string str) {  type=str; }

void add_cmd(string str) { cmds+=({ str }); }

/*********************************/
/* Functions for querying status */
/*********************************/

int query_hp_heal() { return hp_heal; }

int query_sp_heal() { return sp_heal; }

int query_charges() { return charges; }

int query_intox() { return intox; }

int query_stuff() { return stuff; }

int query_soak() { return soak; }

int query_val() { return value; }

string query_short() { return short_desc; }

string query_long() { return long_desc; }

string query_name() { return name; }

string *query_alias() { return alias; }

string query_msg() { return msg; }

string query_msg2() { return msg2; }

string query_type() { return type; }

string *query_cmds() { return cmds; }

/**********************************/
/* Commands                       */
/**********************************/

/* List heals and show their charges. */
int cmd_heals(string str)
{
  mapping heals;
  object ob;
  string *indices;
  int total;
  int i;

  heals=([ ]);
  ob=first_inventory(this_player());
  while(ob)
  {
    if((int)ob->is_heal())
    {
      heals[(string)ob->query_short()]+=(int)ob->query_charges();
      total++;
    }
    ob=next_inventory(ob);
  }

  indices=keys(heals);

  write("Heals                         Charges\n");
  write("-------------------------------------\n");
  for(i=0; i < sizeof(indices); i++)
  {
    write(color_pad(indices[i],30));
    write(heals[indices[i]]+"\n");
  }
  write("You have "+total+" heals.\n");  
  return 1;
}

/* A deep_inventory version of cmd_heals */
int cmd_heals_all(string str)
{
  mapping heals;
  object *inv;
  string *indices;
  int size;
  int i;
  int total;

  heals=([ ]);

  inv=deep_inventory(this_player());
  size=sizeof(inv);

  for(i=0; i < size; i++)
  {
    if(inv[i]->is_heal())
    {
      heals[(string)inv[i]->query_short()]+=(int)inv[i]->query_charges();
      total++;
    }
  }

  indices=keys(heals);

  write("Heals                         Charges\n");
  write("-------------------------------------\n");
  size=sizeof(indices);
  for(i=0; i < size; i++)
  {
    write(color_pad(indices[i],30));
    write(heals[indices[i]]+"\n");
  }
  write("You have "+total+" heals.\n");  
  return 1;
}

make_monster() {
  object monster;
  monster = clone_object("/obj/monster");
  /* name and alias are what the monster is identifyable by */
  monster->set_name("chicken");
  monster->set_alias("rubber chicken");
  monster->set_short("A rubber chicken");
  monster->set_long(
 "A blubbery rubber chicken. Makes you want to kill it, doesn't it?\n");
  monster->set_level(5);
  monster->set_hp(100);
  monster->set_wc(10);
  monster->set_ac(5);
  monster->set_ep(10000);   
  monster->set_align(-100); /* this monster is bad, obviously :) */ 
  /* set up a message seen when the monster is around */
  monster->load_chat("The rubber chicken flobbles.\n");
  monster->set_chat_chance(20); /* 20% chance of seeing it */
  /* set up a message seen when the monster is fighting */
  monster->load_a_chat("The rubber chicken slaps you with its jelly!\n");
  monster->set_a_chat_chance(20);
  return monster; /* return our created monster to the room */
}
               GENERAL
If you haven't read monsterX, then please do so now.
If all the concepts in monster3 and monster3.exp are clear to you, then you
should understand how that method can be applied to weapons, armors, and
other items based on drivers in /obj.
A few notes about heart_beat, etc.
heart_beat is a function that is called every 2 seconds or so. Mostly, the 
things that have it are monsters, players, kids, pets, etc. Living things.
However, every once in a while you code something that needs a 
delay, or something that needs to do something else on a regular basis.
And although the temptation to put it on heart_beat is great, you SHOULD NOT
DO THAT. heart_beat lags the mud bigtime if too many things are on it. There
is a controlable, much more efficient method of doing things on a 
delay basis: call_out (and remove_call_out).
As of this writing, there is an example of call_out in /open/wizardchild/call_out.c
Simply clone that, then read it. Even using call_out on a 1 second delay is more efficient than heart_beat,
primarily because heart_beat is 'global' and call_out is 'local'.
There are really 3 ways to make monsters - this is the least efficient, and
most popular (due to ease of use) method.

inherit "obj/monster";   /* inherit the monster driver */
reset(arg) {
  if(arg) return ;       /* just like the room example */
  ::reset(arg);          /* this is new - the '::' is the scope resolution */
                         /* operator - the usage calls reset() in monster.c */
  set_name("monster");   /* what the monster is called */
  set_alias("a monster"); /* what else he can be called */
  set_short("A monster"); /* what the player sees */
  set_long("A big, fat ugly, monster. Boy is he big, fat, and ugly.\n"
          +"Notice that we can wrap his description.\n");
  /* the following tell us how strong the monster is */
  /* make sure your monsters follow the monster guidelines */
  set_level(20);
  set_hp(500);
  set_wc(30);
  set_ac(17);
  set_ep(1000000);
  set_al(-800);    /* this makes the monster bad */
  load_chat("The monster breaths.\n");   /* a message we say periodically */
  load_chat("The monster sleeps.\n");  /* another message */
  set_chat_chance(20);  /* give us 20% chance of talking */
  load_a_chat("The monster growls.\n");  /* attack chat */
  load_a_chat("The monster grumbles.\n"); /* another attack chat */
  set_a_chat_chance(20); /* 20% chance of attack chatting */
  move_object(clone_object("/players/joebob/itemthing"), this_object());
}
/* notice we don't need id(str) because set_name and set_alias handle it */
This is the second, and rarely used, method of making monsters. The reason
for this is it makes 'killing zones' hard to produce, because you have to
rewrite the monster's configuration for every room. The third method solves
this problem, but not many people pay enough attention to notice that.

/* first, we have a room */
inherit "room/room";
reset(arg) {
  object monster;  /* variable monster is held in */
  if(arg) return ;
  set_light(1);
  short_desc = "A room";
  long_desc = "Just a generic room, with a monster.\n";
  dest_dir = 
  ({
  "room/church", "church"
  });
  monster = clone_object("obj/monster");  /*clone driver */
  monster->set_name("monster"); /* use call_other to configure */
  monster->set_alias("a monster");
  monster->set_short("A monster");
  monster->set_long("This is a long description.\n");
  monster->set_level(20);
  monster->set_wc(30);
  monster->set_ac(17);
  monster->set_hp(500);
  monster->set_ep(1000000);
  monster->set_al(-800);
  monster->load_chat("The monster yawns.\n");
  monster->set_chat_chance(20);
  move_object(clone_object("players/joebob/thingo"), monster);
  move_object(monster, this_object());
}
The third, and most practical, method of making monsters is this one.
However, i don't think i've ever seen it used. The difference in time
is negligible, but it requires more knowledge of what you are doing.
Notice that it involves changes in 2 places.

/* first we have a room */
inherit "room/room";
reset(arg) {
  object monster;
/* reset of the normal junk; short_desc, long_desc, set_light, etc */
/* at the end, it looks like this: */
  monster = "/players/joebob/monsterthingo"->make_monster();
  move_object(monster, this_object());
}
/* stay with me here. the following would be players/joebob/monsterthingo */
make_monster() {
  object monster;
  monster = clone_object("/obj/monster");
  /* inert normal configuration here */
  /* just like in monster 2. at the end, we have the fun */
  return monster; /* return the configured monster */
}
/* please read monster3.exp now ;) */
I'm spending more time talking about this method, primarily because it is the
method that EVERYONE should use from now on. It saves ENORMOUS amounts of
memory (i'll explain belo).
The way this method works is simple:
A room is created. At the end, the room calls on a file for a specific
function, which returns an object pointer to a monster. The room then moves
the monster to itself.
The specific function in the file simply configures the standard
/obj/monster.c driver, and returns it.
Now, on to why it saves memory.
Using the normal method (that described in monster1), for every monster you see,
there is another copy you don't see (well, for ever DIFFERENT monster you see)
This is because clone_object/clone/whatever makes 2 copies one the first
cloning of any object - one which you see, the other which works as a 'server'
for all other copies of that object. When you update an object, you are really
desting that 'server' object, forcing the driver to reload the file from 
disk next time it is referenced.
So if i have 200 monsters in my castle, and i clone each one once using
the first method (monster1), then 400*(size of monster - about 45k) of memory
is used. However, if i have 200 monsters in my castle, and i use method #3
(or method #2), then 200*(size of monster) of memory is used.
On a mud with as many wizards as Nirvana has, that's a lot of memory that
could be saved.
One final note. Using this method, you loose some extra fun stuff that
you can do with monster1. This is the case with armors and weapons
created using this method also.Tinker around, however, and you'll find
ways to add creativity using this method..
inherit "room/room";
reset(arg) {
  object monster;
  if(arg) 
    return ;    
  set_light(1); 
  short_desc = "A Roomy Room"; 
  long_desc  =
 "This is a large, spacious, roomy room. There's lots of room in this room.\n"
+"In fact, there's so much room, that's it's just too roomy.\n";
  dest_dir =
  ({ /* needed to signify an array */
  "/room/church", "church",
  "/room/shop","shop"
  });
  monster = call_other("/open/CODING/beastie","make_monster");
  move_object(monster, this_object());
}
The following is the 'common' structure of a room. Note that you do not have
to write your rooms this way, but there are definite advantages to doing so.

inherit "room/room";    /* inherit the room driver */
reset(arg) {      /* called on object clone, and about every 2 hours */
                  /* on clone, arg = 0, otherwise arg = 1 */
  if(arg) return ;   /* don't change anything unless this is first reset */
  set_light(1);     /* creates light source - remove this line for darkness */
  short_desc = "A room"; /* seen on who, etc w/ exits */
  long_desc = "This is a long description. It can be wrapped around\n"
             +"a line like this.\n";   /* seen when a player looks */
  dest_dir  =
  ({            /* assign the array that holds destinations */
  "room/church", "church",    /* notice filename first, then addresable name */
  "room/shop", "shop"     /* notice no commaa at end */
  });  /* end of assignment */
  /* down here you would clone any objects 
   * for monsters, if you want them to come back before reboot, then you
   * would clone them BEFORE the 'if(arg) return ;' line
  */
  move_object(clone_object("/players/joebob/monstersthing"), this_object());
}
/* call_out.c: example of heart_beat like call_out loops */
short() { return "An example of call out"; }
id(str) { return str == "example"; }
get() { return 1; }
long() { write("Type \"start_example\" or \"stop_now\".\n"); }
init() { 
  if(this_player()->query_level() < 20) destruct(this_object());
  add_action("start", "start_example");
  add_action("stop", "stop_now");
}
set_fake_hb(arg) {
  while(remove_call_out("fake_hb") != -1) ;
  if(arg) call_out("fake_hb", 3);
}
start() {
  set_fake_hb(1);
  write("On.\n");
  return 1;
}
stop()  {
  set_fake_hb(0);
  write("Off.\n");
  return 1;
}
/* placing the set_fake_hb(0) and fake_hb(1) in their positions prevents */
/* mass running on error */
fake_hb() {
  object ob;
  set_fake_hb(0); /* remove overlapping */
  ob = environment(this_object());
  if(!living(ob)) set_fake_hb(0);
  tell_object(ob, "Fake HB called.\n");
  set_fake_hb(1);   
}

SYNOPSIS        mixed clean_up(int refcount)DESCRIPTION        Every object carries a "last time of reference" stamp.        Whenever a function is applied (call_other'ed) this stamp is        set to the current time.        This gives the driver the opportunity to detect if an object        has not been used for a long time. After a specific length of        inactivity, the driver will try to call a "clean_up" function        in the inactive object.        It should come as no surprise that the intention of having        this function called, is to let the object do some cleaning        up. 3 types of behaviour is commonly seen.        * The object decides there is no particular reason to stick        around and destructs itself. The return value doesn't matter.        * The object isn't ready to leave yet, but might do it later.        It returns 1.         * The object doesn't want to be cleaned up, ever.        It returns 0.        The argument 'refcount' that is passed to clean_up() is        always zero for clones. For master copies refcount denotes        the number of clones of that object. It is usually a bad idea        to destruct an object with a refcount > 0.EXAMPLE        mixed clean_up(int refcount) {            if (refcount)                return 1;       /* try later */            if (environment() && living(environment()))                return 1;       /* not yet, carried by a creature */            destruct(this_object());        }SEE ALSO        clone_object(E), reset(A), swap(E)
/*
 * basic/area_map.c provides means to read an ascii map and let the rooms of
 *                  an area be connected automatically according to this map.
 *
 * by Alfe for Tubmud 01-Jun-29
 *
 * features:
 * - bidirectional connections (which are the normal exits) in the eight
 *   normal directions (n,s,w,e, nw,sw,ne,se) can be done automatically
 *   by the mapping algorithm.
 * - other connections (up, down, unidirectionals (one-ways) etc.) can be
 *   added in the direct way using add_exit() or similar.
 *
 * structure of an area map:
 * 1) each room which wants to be part of the map has to get a name of
 *    alphanumeric characters (and _).  it helps to use the file name of
 *    the room and to keep all room files in one directory.  each name
 *    must be used for one room only (in one area map).
 * 2) the ascii graphic map of the area must be stored in a file with the
 *    suffix .map .
 * 3) the map file contains an ascii graphic of the area in which rooms are
 *    notated by their names.  connections are drawn by the characters
 *    | (for north-south connections), - (e-w), / (sw-ne) and \ (se-nw).
 *    more than one character can be used to connect rooms over a longer
 *    distance (see examples below).
 *    - paths must start directly at the name (no space between).
 *    - the path characters must point directly at the room name.
 *    - directions must be straight.
 * 4) if the room names are not matching the base names of the room files,
 *    a mapping or closure can be used.
 * 5) connections of the area towards neighboring areas are not mentioned
 *    in the map.  (they are added by different means.)
 * 6) comments in the map:
 *    - anything is ignored which does not resemble a used room name and
 *      which does not disturb a path.
 *    - after a hash mark (#) the rest of the line is ignored.
 *
 * usage:
 * rooms which want at least some of their exits be generated by an area map
 * will inherit "basic/area_map" and call
 *
 *     map(area_map_exits(<area_map_file>),
 *         (: apply((#'add_exit),$1) :));
 *
 * in their configure().  after this they can call add_exit() again to add
 * further additional exits.
 * if the names used in the area map are not the file names of the room
 * files (or if the rooms files are scattered across various directories),
 * the room should call area_map_exits(<area_map_file>,<map2file>,<file2map>)
 * whereas <map2file> should be a mapping or a closure which maps the map
 * name to the file name and <file2map> vice versa.  both or no mapper must
 * be given.
 *
 * examples:

village.map:

                                                           hilltop
     crypt                               inn--east5           |
         \                                      |    hill4--hill3--cliff2
   wall--graves--chapel                       east4    |  \/  |  \/  |
           |                                    |      |  /\  |  /\  |
sanctury   |         square---sun2----sun1----east3  hill2--hill1--cliff
   |       |                                    |             |
archway---gate        yard--pub2              east2         beach2
   |                    |                       |             |
 church                 |    storage--shop    east1         beach1
   |                    |              |        |             |
 green------track-----road1----------road2----shore--jetty--shore2--jetty2-sea
                        |              |        |      |
                        |            guild    crop   syne1
                        |                              |
                      alley--bank                    syne2
                        |                              |
                      post                           syne3
                                                       |
                             oak12                   syne4
                               |                       |
                   south11--south10--south9--south8--syne5
                                                       |
                                                     syne6
                                                       |
                                                     syne7
 */

#include <closures.h>
#include <assert.h>
#include <ctype.h>

int *find_room_in_map(string *map,string room_map_name) {
  int line;
  string *parts;
  // check argument types:
  assert(pointerp(map));
  assert(stringp(room_map_name));
  // function:
  for (line=sizeof(map); line-->0; )
    if (sizeof(parts=regexplode(map[line],"\\<" + room_map_name + "\\>")) > 1)
      return ({ strlen(parts[0]), line });
  return 0;  // flag for: not found
}

string *get_map(string map_file_name) {
  mixed map;
  // check argument types:
  assert(stringp(map_file_name));
  // function:
  map = (read_file(map_file_name + ".map") ||
         read_file(map_file_name) ||
         raise_error("no such map file: " + map_file_name + "[.map]\n"));
  if (member(map,'\t') >= 0)
    raise_error("map file contains tab stops: " + map_file_name + "\n");
  return map(explode(map,"\n"),(: explode($1,"#")[0] :));
}

private status isalnumus(int c) {  // is alpha numeric or underscore?
  // check argument types:
  assert(intp(c));
  // function:
  return isalnum(c) || c == '_';
}

private int map_char(string *map,int x,int y) {
  // check argument types:
  assert(pointerp(map));
  assert(intp(x));
  assert(intp(y));
  // function:
  if (y < 0 || y >= sizeof(map) ||
      x < 0 || x >= strlen(map[y]))
    return 0;
  return map[y][x];
}

private string get_room_name_at(string *map,int x,int y) {
  int x1, x2;
  string result;
  // check argument types:
  assert(pointerp(map));
  assert(intp(x));
  assert(intp(y));
  // function:
  for (x1 = x; isalnumus(map_char(map,x1,y)); x1--)
    ;
  for (x2 = x; isalnumus(map_char(map,x2,y)); x2++)
    ;
  result = map[y][x1+1..x2-1];
  return (result != "") && result;
}

#define RUNAWAY(dir,x,y)                                              \
  raise_error("Runaway " "dir" "ern exit of room " + room_map_name +  \
              " in map " + map_file_name + " at line " + y +          \
              ", column " + x + "\n")

mixed *find_room_connections(string map_file_name,string room_map_name) {
  int *room_pos, x, y, x_, y_, c;
  mixed *result;
  string *map, neighbour;
  // check argument types:
  assert(stringp(map_file_name));
  assert(stringp(room_map_name));
  // function:
  map = get_map(map_file_name);
  result = ({});
  room_pos = find_room_in_map(map,room_map_name);
  if (!room_pos) {
#if 0
    raise_error("Room " + room_map_name +
                " not found in map " + map_file_name + "\n");
#else
    return ({});  // it turned out that a missing room could well be a
                  // base class and thus should not lead to this error...
#endif
  }
  x = room_pos[0];
  y = room_pos[1];
  // western exit?
  //// find start
  x_ = x-1;
  if (map_char(map,x_--,y) == '-') {  // found western exit!
    //// iterate to end of path
    while ((c=map_char(map,x_,y)) == '-')
      x_--;
    if (!c || !(neighbour=get_room_name_at(map,x_,y)))
      RUNAWAY(west,x_,y);
    result += ({ ({ neighbour,"west" }) });
  }
  // eastern exit?
  //// find start
  x_ = x + strlen(room_map_name);
  if (map_char(map,x_++,y) == '-') {  // found eastern exit!
    //// iterate to end of path
    while ((c=map_char(map,x_,y)) == '-')
      x_++;
    if (!c || !(neighbour=get_room_name_at(map,x_,y)))
      RUNAWAY(east,x_,y);
    result += ({ ({ neighbour,"east" }) });
  }
  // northern exit?
  //// find start
  y_ = y - 1;
  x_ = x;
  while ((c=map_char(map,x_,y_)) != '|' && x_ < x+strlen(room_map_name))
    x_++;
  if (c == '|') {  // found northern exit!
    //// iterate to end of path
    do {
      y_--;
    } while ((c=map_char(map,x_,y_)) == '|');
    if (!c || !(neighbour=get_room_name_at(map,x_,y_)))
      RUNAWAY(north,x_,y_);
    result += ({ ({ neighbour,"north" }) });
  }
  // southern exit?
  y_ = y + 1;
  x_ = x;
  while ((c=map_char(map,x_,y_)) != '|' && x_ < x+strlen(room_map_name))
    x_++;
  if (c == '|') {  // found southern exit!
    //// iterate to end of path
    do {
      y_++;
    } while ((c=map_char(map,x_,y_)) == '|');
    if (!c || !(neighbour=get_room_name_at(map,x_,y_)))
      RUNAWAY(south,x_,y_);
    result += ({ ({ neighbour,"south" }) });
  }
  // northwest?
  y_ = y - 1;
  x_ = x - 1;
  while ((c=map_char(map,x_,y_)) != '\\' && x_ < x+strlen(room_map_name)-1)
    x_++;
  if (c == '\\') {  // found northwestern exit!
    //// iterate to end of path
    do {
      y_--, x_--;
    } while ((c=map_char(map,x_,y_)) == '\\');
    if (!c || !(neighbour=get_room_name_at(map,x_,y_)))
      RUNAWAY(northwest,x_,y_);
    result += ({ ({ neighbour,"northwest" }) });
  }
  // northeast?
  y_ = y - 1;
  x_ = x + 1;
  while ((c=map_char(map,x_,y_)) != '/' && x_ < x+strlen(room_map_name)+1)
    x_++;
  if (c == '/') {  // found northeastern exit!
    //// iterate to end of path
    do {
      y_--, x_++;
    } while ((c=map_char(map,x_,y_)) == '/');
    if (!c || !(neighbour=get_room_name_at(map,x_,y_)))
      RUNAWAY(northeast,x_,y_);
    result += ({ ({ neighbour,"northeast" }) });
  }
  // southwest?
  y_ = y + 1;
  x_ = x - 1;
  while ((c=map_char(map,x_,y_)) != '/' && x_ < x+strlen(room_map_name)-1)
    x_++;
  if (c == '/') {  // found southwestern exit!
    //// iterate to end of path
    do {
      y_++, x_--;
    } while ((c=map_char(map,x_,y_)) == '/');
    if (!c || !(neighbour=get_room_name_at(map,x_,y_)))
      RUNAWAY(southwest,x_,y_);
    result += ({ ({ neighbour,"southwest" }) });
  }
  // southeast?
  y_ = y + 1;
  x_ = x + 1;
  while ((c=map_char(map,x_,y_)) != '\\' && x_ < x+strlen(room_map_name)+1)
    x_++;
  if (c == '\\') {  // found southeastern exit!
    //// iterate to end of path
    do {
      y_++, x_++;
    } while ((c=map_char(map,x_,y_)) == '\\');
    if (!c || !(neighbour=get_room_name_at(map,x_,y_)))
      RUNAWAY(southeast,x_,y_);
    result += ({ ({ neighbour,"southeast" }) });
  }
  return result;
}

mixed *area_map_exits_for_object(string room_file_name,
                                 string map_file_name,
                                 closure map2file,
                                 closure file2map) {
  int *room_pos;
  string room_map_name;
  mixed *connections;
  // check argument types:
  assert(stringp(room_file_name));
  assert(stringp(map_file_name));
  assert(closurep(map2file));
  assert(closurep(file2map));
  // function:
  room_map_name = funcall(file2map,room_file_name);
  connections = find_room_connections(map_file_name,room_map_name);
  return map(connections,(: ({ funcall($2,$1[0]),$1[1] }) :),map2file);
}

varargs mixed *area_map_exits(string map_file_name,
                              mixed map2file,
                              mixed file2map) {
  // check argument types:
  assert(stringp(map_file_name));
  assert(!map2file || closurep(map2file) || mappingp(map2file));
  assert(!file2map || closurep(file2map) || mappingp(file2map));
  assert( map2file &&  file2map ||
         !map2file && !file2map);
  // function:
  if (mappingp(map2file))
    map2file = lambda(({ 'x }),({ CL_INDEX,map2file,'x }));
  else if (!map2file)
    map2file = (: "./" + $1 :);
  if (mappingp(file2map))
    file2map = lambda(({ 'x }),({ CL_INDEX,file2map,'x }));
  else if (!file2map)
    file2map = (: explode($1,"/")[<1] :);
  return area_map_exits_for_object(object_name(this_object()),
                                   map_file_name,
                                   map2file,
                                   file2map);
}

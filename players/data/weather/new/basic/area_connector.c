/*
 * basic/area_connector.c provides means for castles of areas to connect
 *                        an area to various others.
 *
 * by Alfe for Tubmud 2001-Jun-30
 *
 * features:
 * - bidirectional connections (which are the normal exits) in the eight
 *   normal directions (n,s,w,e, nw,sw,ne,se) can be done automatically
 *   by the mapping algorithm.
 * - other connections (up, down, unidirectionals (one-ways) etc.) can be
 *   added in the direct way using add_exit() or similar.
 *
 * usage:
 * area castles which want at least some of their area connections be
 * generated by this facility inherit "basic/area_connector" and call
 *
 *     add_area_connection(<room1>,<room2>,<direction>);
 *
 * for each connection they wish to add.  this could be done in their
 * create() or in subfunction called by it.  if you wish to add extra_longs
 * to the rooms which bear the connection, just give two further arguments
 * to add_area_connection() for each desc: <key1>, <desc1> and <key2>, <desc2>
 * (the <key1> etc are needed by the extra_long facility).
 *
 * <room1> and <room2> must be given as strings, <direction> must be the
 * direction leading from <room1> to <room2> (e.g. "north"); this will add
 * a matching exit in each of both rooms.
 *
 * to revoke a connection (e.g. to disconnect an area) the castle would
 * call
 *
 *     remove_area_connection(<room1>,<room2>,<direction>);
 *
 * if the castle overloads the function notify_destruct(), it should call
 * "basic/area_connector"::notify_destruct(); in it because by this the
 * area connections are revoked automatically (which should be the normal
 * thing when a castle is destructed).
 */

#include <assert.h>
#include <server.h>

inherit "basic/orientation";

#define BUILD_ENTRY(room1,room2,direction) \
                                  ((room1) + "%" + (room2) + "%" + (direction))

private mapping area_connections;
private mapping connected_rooms;

mapping *query_area_connections() {
  return ({ area_connections, connected_rooms });
}

varargs void add_area_connection(string room1, string room2,
                                 string direction,
                                 mixed key1, mixed desc1,
                                 mixed key2, mixed desc2) {
  string reverse;
  // check argument types:
  assert(stringp(room1));
  assert(stringp(room2));
  assert(stringp(direction));
  // function:
  if (!area_connections)
    area_connections = ([]);
  area_connections[BUILD_ENTRY(room1,room2,direction)] = ({ room1,
                                                            room2,direction });
  if (!connected_rooms)
    connected_rooms = ([]);
  if (connected_rooms[room1])
    connected_rooms[room1] += ({ ({ room2,direction,key1,desc1 }) });
  else
    connected_rooms[room1] = ({ ({ room2,direction,key1,desc1 }) });
  SE_NOTIFIER->add_notify(room1,"connect_area_room");
  reverse = orientation_reverse(direction);
  if (connected_rooms[room2])
    connected_rooms[room2] += ({ ({ room1,reverse,key2,desc2 }) });
  else
    connected_rooms[room2] = ({ ({ room1,reverse,key2,desc2 }) });
  SE_NOTIFIER->add_notify(room2,"connect_area_room");
}

void remove_area_connection(string room1, string room2, string direction) {
  int i;
  mixed *connections;
  string reverse;
  // check argument types:
  assert(stringp(room1));
  assert(stringp(room2));
  assert(stringp(direction));
  // function:
  connections = connected_rooms[room1];
  for (i=sizeof(connections); i-->0; ) {
    if (connections[i][0] == room2 &&
        connections[i][1] == direction) {
      room1->remove_exit(direction);
      tell_room(room1,
                "Suddenly, the exit to the " + direction + " vanishes!\n");
      if (connections[i][3]) {  // extra_long desc?
        room1->remove_extra_long(connections[i][2]);
        tell_room(room1,"Something has changed ...\n");
      }
      connected_rooms[room1][i..i] = ({});  // working on 'connections' here
                                            // wouldn't change this original!
    }
  }
  if (!sizeof(connected_rooms[room1])) {  // no reason to listen anymore?
    SE_NOTIFIER->remove_notify(room1,this_object());
    m_delete(connected_rooms,room1);  // forget this room completely
  }
  reverse = orientation_reverse(direction);
  connections = connected_rooms[room2];
  for (i=sizeof(connections); i-->0; ) {
    if (connections[i][0] == room1 &&
        connections[i][1] == reverse) {
      room2->remove_exit(reverse);
      tell_room(room2,"Suddenly, the exit to the " + reverse + " vanishes!\n");
      if (connections[i][3]) {  // extra_long desc?
        room2->remove_extra_long(connections[i][2]);
        tell_room(room2,"Something has changed ...\n");
      }
      connected_rooms[room2][i..i] = ({});  // working on 'connections' here
                                            // wouldn't change this original!
    }
  }
  if (!sizeof(connected_rooms[room2])) {  // no reason to listen anymore?
    SE_NOTIFIER->remove_notify(room2,this_object());
    m_delete(connected_rooms,room2);  // forget this room completely
  }
  m_delete(area_connections,BUILD_ENTRY(room1,room2,direction));
}

void notify_destruct() {
  map(m_values(area_connections),(: apply((#'remove_area_connection),$1) :));
}

// this gets called by SE_NOTIFIER whenever one of our candidates is created
public void connect_area_room(string room_file_name, status refresh) {
  object room, partner;
  string direction;
  mixed key, desc;
  mixed *connections;
  int i;
  status newly;
  // check argument types:
  assert(stringp(room_file_name));
  assert(intp(refresh));
  // function:
  room = find_object(room_file_name);
  if (!room)
    raise_error("Couldn't find room " + room_file_name + "\n");
  connections = connected_rooms[room_file_name];
  if (!connections)
    raise_error("Don't know anything about room " + room_file_name + "\n");
  for (i=sizeof(connections); i-->0; ) {
    partner   = connections[i][0];
    direction = connections[i][1];
    key       = connections[i][2];
    desc      = connections[i][3];
    newly = !(room->query_exit(direction));
    room->add_exit(partner,direction);
    if (newly)
      tell_room(room,
                "Suddenly, a new exit to the " + direction + " appears.\n");
    if (desc && room->query_extra_long(key) != desc) {
      room->add_extra_long(key,desc);
      tell_room(room,"Something has changed ...\n" + funcall(desc));
    }
  }
}

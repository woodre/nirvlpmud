I'm spending more time talking about this method, primarily because it is the
method that EVERYONE should use from now on. It saves ENORMOUS amounts of
memory (i'll explain belo).
The way this method works is simple:
A room is created. At the end, the room calls on a file for a specific
function, which returns an object pointer to a monster. The room then moves
the monster to itself.
The specific function in the file simply configures the standard
/obj/monster.c driver, and returns it.
Now, on to why it saves memory.
Using the normal method (that described in monster1), for every monster you see,
there is another copy you don't see (well, for ever DIFFERENT monster you see)
This is because clone_object/clone/whatever makes 2 copies one the first
cloning of any object - one which you see, the other which works as a 'server'
for all other copies of that object. When you update an object, you are really
desting that 'server' object, forcing the driver to reload the file from 
disk next time it is referenced.
So if i have 200 monsters in my castle, and i clone each one once using
the first method (monster1), then 400*(size of monster - about 45k) of memory
is used. However, if i have 200 monsters in my castle, and i use method #3
(or method #2), then 200*(size of monster) of memory is used.
On a mud with as many wizards as Nirvana has, that's a lot of memory that
could be saved.
One final note. Using this method, you loose some extra fun stuff that
you can do with monster1. This is the case with armors and weapons
created using this method also.Tinker around, however, and you'll find
ways to add creativity using this method..
